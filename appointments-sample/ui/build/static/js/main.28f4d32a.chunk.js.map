{"version":3,"sources":["shared/AppointmentState.ts","shared/common/SignalRNotifications.ts","common/DurableHttpClient.ts","shared/common/Constants.ts","common/DurableEntitySet.ts","App.tsx","index.tsx"],"names":["AppointmentStatusEnum","EntityStateChangedMessage","entityName","entityKey","version","stateDiff","isEntityDestructed","msg","FormatEntityId","BackendBaseUri","DurableHttpClient","_configFabric","NullLogger","instance","request","path","url","startsWith","split","slice","join","includes","config","this","accessTokenFactory","then","accessToken","headers","fakeUserNamePromise","fakeUserName","DefaultHttpClient","DurableEntitySet","_entityName","attachToAll","items","toLowerCase","makeObservable","observable","attachAllEntities","initSignalR","EntitySets","fetchAndApplyAllEntityStates","entityId","EntityStates","attachEntity","undefined","createEntity","signalName","argument","signalEntity","metadata","updateEntityMetadata","initialState","state","makeAutoObservable","fetchAndApplyEntityState","uri","HttpClient","post","content","JSON","stringify","Config","logger","entityState","entitySet","push","i","length","splice","desiredVersion","retryCount","currentEntityState","get","response","stateContainer","parse","Error","diff","rfc6902","entityAdded","catch","err","MaxRetryCount","setTimeout","RetryBaseIntervalMs","log","LogLevel","item","GetEntityId","Trace","entityDeleted","expectedVersion","SignalRConn","HubConnectionBuilder","withUrl","httpClient","build","on","entityStateChangedMessageHandler","onclose","tryToReconnect","Information","start","SignalRReconnectIntervalInMs","setup","l","console","Promise","resolve","fetch","r","json","result","appState","userName","user_id","prompt","participantsText","appointments","App","observer","participants","map","p","trim","filter","newAppointmentId","Date","toISOString","AppBar","position","color","className","Toolbar","TextField","fullWidth","label","placeholder","InputLabelProps","shrink","variant","size","value","onChange","evt","target","onKeyPress","key","preventDefault","createNewAppointment","Box","width","Button","onClick","AccountCircle","Typography","List","appointment","ListItem","Paper","Grid","container","spacing","xs","status","Pending","Chip","Accepted","Declined","Object","keys","name","disabled","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.28f4d32a.chunk.js","sourcesContent":["\r\nexport enum AppointmentStatusEnum {\r\n    Pending = 0,\r\n    Accepted,\r\n    Declined\r\n}\r\n\r\n// Appointment state\r\nexport class AppointmentState\r\n{\r\n    participants: { [name: string]: AppointmentStatusEnum } = {};\r\n    status: AppointmentStatusEnum = AppointmentStatusEnum.Pending;\r\n}","import * as rfc6902 from 'rfc6902';\r\n\r\nexport class EntityStateChangedMessage {\r\n    \r\n    entityName: string = '';\r\n    entityKey: string = '';\r\n    version: number = 0;\r\n    stateDiff: rfc6902.Operation[] = [];\r\n    isEntityDestructed: boolean = false;\r\n\r\n    static GetEntityId(msg: EntityStateChangedMessage): string {\r\n        return EntityStateChangedMessage.FormatEntityId(msg.entityName, msg.entityKey);\r\n    }\r\n\r\n    static FormatEntityId(entityName: string, entityKey: string): string {\r\n        return `@${entityName}@${entityKey}`;\r\n    }\r\n}","import { DefaultHttpClient, HttpRequest, HttpResponse, NullLogger } from '@aspnet/signalr';\r\n\r\nimport { IDurableEntitySetConfig } from './IDurableEntitySetConfig';\r\nimport { ClientPrincipalHeaderName } from '../shared/common/Constants';\r\n\r\nexport const BackendBaseUri = '/a/p/i';\r\n\r\n// Custom HttpClient implementation for the purposes of DurableEntitySet\r\nexport class DurableHttpClient extends DefaultHttpClient {\r\n\r\n    constructor(private _configFabric: () => IDurableEntitySetConfig) {\r\n        super(NullLogger.instance);\r\n    }\r\n\r\n    send(request: HttpRequest): Promise<HttpResponse> {\r\n\r\n        // Applying custom config settings, but only when calling our backend\r\n\r\n        var path = request.url!;\r\n        if (path.startsWith('http')) {\r\n            path = '/' + path.split('/').slice(3).join('/');\r\n        }\r\n\r\n        if (path.includes(BackendBaseUri)) {\r\n\r\n            const config = this._configFabric();\r\n\r\n            if (!!config.accessTokenFactory) {\r\n                return config.accessTokenFactory().then(accessToken => {\r\n\r\n                    request.headers = {}\r\n                    request.headers['Authorization'] = 'Bearer ' + accessToken;\r\n\r\n                    return super.send(request);\r\n                });\r\n            }\r\n\r\n            if (!!config.fakeUserNamePromise) {\r\n                return config.fakeUserNamePromise.then(fakeUserName => {\r\n\r\n                    if (!!fakeUserName) {\r\n                        request.headers = {}\r\n                        request.headers[ClientPrincipalHeaderName] = fakeUserName;\r\n                    }\r\n\r\n                    return super.send(request);\r\n                });\r\n            }\r\n        }\r\n\r\n        return super.send(request);\r\n    }\r\n}\r\n","\r\nexport const SignalRClientHandlerName = \"entity-state-changed\";\r\n\r\nexport const ClientPrincipalHeaderName = 'x-ms-client-principal-name';\r\n\r\nexport const UpdateMetadataServiceMethodName = \"$update-entity-internal-metadata\";\r\n","import { makeAutoObservable, makeObservable, observable } from 'mobx';\r\nimport { HubConnectionBuilder, HubConnection, NullLogger, LogLevel } from '@aspnet/signalr';\r\nimport * as rfc6902 from 'rfc6902';\r\n\r\nimport { ISetEntityMetadataRequest } from '../shared/common/ISetEntityMetadataRequest';\r\nimport { EntityStateChangedMessage } from '../shared/common/SignalRNotifications';\r\nimport { SignalRClientHandlerName, UpdateMetadataServiceMethodName } from '../shared/common/Constants';\r\nimport { DurableEntityClientStateContainer } from '../shared/common/DurableEntityClientStateContainer';\r\nimport { IDurableEntitySetConfig } from './IDurableEntitySetConfig';\r\nimport { DurableHttpClient, BackendBaseUri } from './DurableHttpClient';\r\n\r\nexport type EntityStateWithKey = { entityKey: string };\r\n\r\n// Client-side container for Durable Entities\r\nexport class DurableEntitySet<TState extends object> {\r\n\r\n    // All attached entities will appear in this observable array\r\n    items: (TState & EntityStateWithKey)[] = [];\r\n    \r\n    constructor(private _entityName: string, attachToAll: boolean = true) {\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        this._entityName = this._entityName.toLowerCase();\r\n\r\n        makeObservable(this, { items: observable });\r\n        \r\n        if (attachToAll) {\r\n            this.attachAllEntities();\r\n        }\r\n    }\r\n\r\n    // Attach all entities of this type (that type you previously passed to ctor).\r\n    // Preloads all existing entities of this type and then automatically captures all newly created entities.\r\n    attachAllEntities(): void {\r\n\r\n        DurableEntitySet.initSignalR();\r\n\r\n        // Registering ourselves as listeners for this type of entity\r\n        DurableEntitySet.EntitySets[this._entityName] = this.items;\r\n\r\n        // Loading all existing entities\r\n        DurableEntitySet.fetchAndApplyAllEntityStates(this._entityName);\r\n    }\r\n\r\n    // Manually attach a single entity with specific key\r\n    attachEntity(entityKey: string): void {\r\n\r\n        const entityId = EntityStateChangedMessage.FormatEntityId(this._entityName, entityKey);\r\n\r\n        if (!!DurableEntitySet.EntityStates[entityId]) {\r\n            return;\r\n        }\r\n\r\n        // Registering ourselves as listeners for this particular entity\r\n        DurableEntitySet.EntitySets[entityId] = this.items;\r\n        \r\n        DurableEntitySet.attachEntity(this._entityName, entityKey, undefined as any);\r\n    }\r\n\r\n    // Creates (or fetches existing) an entity\r\n    createEntity(entityKey: string): void {\r\n\r\n        DurableEntitySet.createEntity(this._entityName, entityKey, undefined as any);\r\n    }\r\n\r\n    // Sends a signal to the given entity\r\n    signalEntity(entityKey: string, signalName: string, argument?: any): Promise<void> {\r\n\r\n        return DurableEntitySet.signalEntity(this._entityName, entityKey, signalName, argument);\r\n    }\r\n\r\n    // Updates metadata of the given entity\r\n    updateEntityMetadata(entityKey: string, metadata: ISetEntityMetadataRequest): Promise<void> {\r\n\r\n        return DurableEntitySet.updateEntityMetadata(this._entityName, entityKey, metadata);\r\n    }\r\n\r\n    // Produces a single observable state instance for an existing entity\r\n    static attachEntity<TState extends object>(entityName: string, entityKey: string, initialState: TState): TState {\r\n\r\n        DurableEntitySet.initSignalR();\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        entityName = entityName.toLowerCase();\r\n\r\n        const entityId = EntityStateChangedMessage.FormatEntityId(entityName, entityKey);\r\n        if (!!this.EntityStates[entityId]) {\r\n            // If it is a known entity, then just returning it\r\n            return this.EntityStates[entityId].state as TState;\r\n        }\r\n\r\n        if (!!initialState) {\r\n            makeAutoObservable(initialState);\r\n        }\r\n\r\n        // Try to asynchronously retrieve the state from server\r\n        this.fetchAndApplyEntityState(entityName, entityKey, 0, 0, initialState);\r\n\r\n        return initialState;\r\n    }\r\n\r\n    // Creates (or fetches existing) and produces a single observable state instance for a newly created entity\r\n    static createEntity<TState extends object>(entityName: string, entityKey: string, initialState: TState): TState {\r\n\r\n        // This empty request will create the entity, if it doesn't exist yet.\r\n        this.updateEntityMetadata(entityName, entityKey, {});\r\n\r\n        return this.attachEntity(entityName, entityKey, initialState);\r\n    }\r\n\r\n    // Sends a signal to the given entity\r\n    static signalEntity(entityName: string, entityKey: string, signalName: string, argument?: any): Promise<void> {\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        entityName = entityName.toLowerCase();\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityName}/${entityKey}/${signalName}`;\r\n        return this.HttpClient.post(uri, { content: JSON.stringify(argument) }).then();\r\n    }\r\n\r\n    // Updates metadata of the given entity\r\n    static updateEntityMetadata(entityName: string, entityKey: string, metadata: ISetEntityMetadataRequest): Promise<void> {\r\n\r\n        return this.signalEntity(entityName, entityKey, UpdateMetadataServiceMethodName, metadata);\r\n    }\r\n\r\n    // Optionally setup with these optional settings\r\n    static setup(config: IDurableEntitySetConfig): void {\r\n        this.Config = config;\r\n        if (!this.Config.logger) {\r\n            this.Config.logger = NullLogger.instance;\r\n        }\r\n    }\r\n\r\n    private static Config: IDurableEntitySetConfig = { logger: NullLogger.instance };\r\n    private static HttpClient: DurableHttpClient = new DurableHttpClient(() => DurableEntitySet.Config);\r\n\r\n    private static EntitySets: { [entityName: string]: EntityStateWithKey[] } = {};\r\n    private static EntityStates: { [entityId: string]: DurableEntityClientStateContainer } = {};\r\n    private static SignalRConn: HubConnection;\r\n\r\n    private static readonly SignalRReconnectIntervalInMs = 5000;\r\n    private static readonly MaxRetryCount = 6;\r\n    private static readonly RetryBaseIntervalMs = 500;\r\n\r\n    private static entityAdded(entityName: string, entityKey: string, entityState: EntityStateWithKey) {\r\n\r\n        const entityId = EntityStateChangedMessage.FormatEntityId(entityName, entityKey);\r\n\r\n        // Searching for entitySet either for this particular entity or for this type of entity\r\n        var entitySet = this.EntitySets[entityId];\r\n        if (!entitySet) {\r\n            entitySet = this.EntitySets[entityName];\r\n        } else {\r\n            delete this.EntitySets[entityId];\r\n        }\r\n\r\n        if (!entitySet) {\r\n            return;\r\n        }\r\n\r\n        // Adding the entityKey property to the state object, to allow binding commands\r\n        entityState.entityKey = entityKey;\r\n        entitySet.push(entityState);\r\n    }\r\n\r\n    private static entityDeleted(entityName: string, entityKey: string) {\r\n\r\n        const entitySet = this.EntitySets[entityName];\r\n        if (!entitySet) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < entitySet.length; i++) {\r\n\r\n            if (entitySet[i].entityKey === entityKey) {\r\n                entitySet.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static fetchAndApplyEntityState(entityName: string, entityKey: string, desiredVersion: number, retryCount: number, currentEntityState: any = null): void {\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityName}/${entityKey}`;\r\n        this.HttpClient.get(uri).then(response => {\r\n\r\n            const stateContainer = JSON.parse(response.content as string) as DurableEntityClientStateContainer;\r\n            const entityId = EntityStateChangedMessage.FormatEntityId(entityName, entityKey);\r\n\r\n            if (!!desiredVersion && (stateContainer.version < desiredVersion)) {\r\n                throw new Error(`Expected ${entityId} of version ${desiredVersion}, but got version ${stateContainer.version}`);\r\n            }\r\n\r\n            if (!currentEntityState) {\r\n\r\n                // If there is no existing state, then using the newly arrived state object\r\n                currentEntityState = stateContainer.state;\r\n                makeAutoObservable(currentEntityState);\r\n                \r\n            } else {\r\n\r\n                // Otherwise applying the change to the existing object, so that UI is re-rendered\r\n                (stateContainer.state as any).entityKey = currentEntityState.entityKey; // Need to preserve the entityKey field, if it is set\r\n                const diff = rfc6902.createPatch(currentEntityState, stateContainer.state);\r\n                rfc6902.applyPatch(currentEntityState, diff);\r\n            }\r\n\r\n            if (!this.EntityStates[entityId]) {\r\n                \r\n                // Adding the newly-arrived state into collections, if any\r\n                this.entityAdded(entityName, entityKey, currentEntityState);\r\n            }\r\n\r\n            // (Re)registering this entity\r\n            this.EntityStates[entityId] = { state: currentEntityState, version: stateContainer.version };\r\n\r\n        }).catch(err => {\r\n\r\n            if (retryCount < this.MaxRetryCount) {\r\n\r\n                // Retrying\r\n                retryCount++;\r\n                setTimeout(() => {\r\n\r\n                    this.fetchAndApplyEntityState(entityName, entityKey, desiredVersion, retryCount, currentEntityState);\r\n\r\n                }, retryCount * this.RetryBaseIntervalMs);\r\n                \r\n            } else {\r\n\r\n                this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to fetch entity state: ${err}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    private static fetchAndApplyAllEntityStates(entityName: string): void {\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityName}`;\r\n        this.HttpClient.get(uri).then(response => {\r\n\r\n            for (var item of JSON.parse(response.content as string)) {\r\n\r\n                const entityKey = item.entityKey;\r\n                const entityId = EntityStateChangedMessage.FormatEntityId(entityName, entityKey);\r\n                const stateContainer = item as DurableEntityClientStateContainer;\r\n\r\n                makeAutoObservable(stateContainer.state);\r\n                this.EntityStates[entityId] = stateContainer;\r\n\r\n                // Adding the newly-arrived state into collections, if any\r\n                this.entityAdded(entityName, entityKey, stateContainer.state as any);\r\n            }\r\n\r\n        }).catch(err => {\r\n            this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to fetch entity states: ${err}`);\r\n        });\r\n    }\r\n\r\n    private static entityStateChangedMessageHandler(msg: EntityStateChangedMessage): void {\r\n\r\n        const entityId = EntityStateChangedMessage.GetEntityId(msg);\r\n\r\n        this.Config.logger!.log(LogLevel.Trace, `DurableEntitySet: ${entityId} changed to version ${msg.version}`);\r\n\r\n        if (msg.isEntityDestructed) {\r\n\r\n            delete this.EntityStates[entityId];\r\n\r\n            this.entityDeleted(msg.entityName, msg.entityKey);\r\n\r\n        } else if (!this.EntityStates[entityId]) {\r\n\r\n            // If anybody is attached to this entity or this type of entity\r\n            if (!!this.EntitySets[entityId] || !!this.EntitySets[msg.entityName]) {\r\n                \r\n                // This entity is not known to us yet, so just trying to fetch its state from server\r\n                setTimeout(() => this.fetchAndApplyEntityState(msg.entityName, msg.entityKey, msg.version, 0), this.RetryBaseIntervalMs);\r\n            }\r\n           \r\n        } else {\r\n\r\n            const expectedVersion = this.EntityStates[entityId].version + 1;\r\n            if (msg.version > expectedVersion) {\r\n                \r\n                // Missed some updates, so now need to reload the state from server\r\n                this.fetchAndApplyEntityState(msg.entityName, msg.entityKey, msg.version, 0, this.EntityStates[entityId].state);\r\n\r\n            } else if (msg.version === expectedVersion) {\r\n\r\n                // Applying the change\r\n                rfc6902.applyPatch(this.EntityStates[entityId].state, msg.stateDiff);\r\n                this.EntityStates[entityId].version = msg.version;\r\n            }            \r\n        }\r\n    }\r\n\r\n    private static initSignalR(): void {\r\n\r\n        if (!!this.SignalRConn) {\r\n            return;\r\n        }\r\n\r\n        // Configuring SignalR\r\n        this.SignalRConn = new HubConnectionBuilder()\r\n            .withUrl(`${BackendBaseUri}`, { httpClient: this.HttpClient, logger: this.Config.logger })\r\n            .build();\r\n\r\n        // Mounting the event handler\r\n        this.SignalRConn.on(SignalRClientHandlerName, msg => this.entityStateChangedMessageHandler(msg));\r\n\r\n        // Background reconnects are essential here. That's because in 'Default' or 'Classic' service mode\r\n        // clients get forcibly disconnected, when your backend restarts.\r\n        this.SignalRConn.onclose(() => {\r\n            var tryToReconnect = () => {\r\n                this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: reconnecting to SignalR...`);\r\n                this.SignalRConn.start().then(() => {\r\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: reconnected to SignalR`);\r\n                }, () => {\r\n                    setTimeout(tryToReconnect, this.SignalRReconnectIntervalInMs);\r\n                })\r\n            }\r\n            tryToReconnect();\r\n        });\r\n\r\n        // Establishing SignalR connection\r\n        this.SignalRConn.start().then(\r\n            () => {\r\n                this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: successfully connected to SignalR`);\r\n            }, err => {\r\n                this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to connect to SignalR: ${err}`);\r\n            });\r\n    }\r\n}","import React from 'react';\r\nimport { makeAutoObservable } from 'mobx';\r\nimport { observer } from 'mobx-react';\r\nimport { AppBar, Button, Box, Chip, Grid, List, ListItem, Paper, TextField, Toolbar, Typography } from '@material-ui/core';\r\nimport { AccountCircle } from '@material-ui/icons';\r\n\r\nimport { DurableEntitySet } from './common/DurableEntitySet';\r\nimport { AppointmentState, AppointmentStatusEnum } from './shared/AppointmentState';\r\n\r\n// Setting up DurableEntitySet\r\nDurableEntitySet.setup({\r\n    logger: { log: (l, msg: string) => console.log(msg) },\r\n\r\n    fakeUserNamePromise: new Promise<string | null>((resolve) => {\r\n\r\n        // Trying to fetch current user name from server - this should work when deployed to Azure and EasyAuth properly configured\r\n        fetch('/.auth/me').then(r => r.json()).then(result => {\r\n\r\n            if (!result || !result.length) {\r\n                throw new Error('EasyAuth seems to be not configured. Falling back to a fake user name');\r\n            }\r\n\r\n            appState.userName = result[0].user_id;\r\n\r\n            // By returning null here we tell DurableEntitySet to proceed with using EasyAuth\r\n            resolve(null);\r\n\r\n        }).catch(() => {\r\n\r\n            // Asking the user for some fake user name. Obviously, we should never do it like that in production.\r\n            appState.userName = prompt('Enter your name:', 'Anonymous') as string;\r\n            resolve(appState.userName);\r\n        });\r\n    })\r\n});\r\n\r\n// App state container\r\nconst appState = makeAutoObservable({\r\n    userName: '',\r\n\r\n    participantsText: '',\r\n\r\n    // Here all appointment entities will appear\r\n    appointments: new DurableEntitySet<AppointmentState>('AppointmentEntity')\r\n});\r\n\r\n// Rendering that entity state\r\nexport const App = observer(\r\n    class App extends React.Component {\r\n\r\n        private createNewAppointment() {\r\n\r\n            const participants = appState.participantsText\r\n                .split(',')\r\n                .map(p => p.trim())\r\n                .filter(p => !!p);\r\n\r\n            // Generating unique entity key\r\n            const newAppointmentId = 'APP-' + new Date().toISOString();\r\n\r\n            // Creating a new entity\r\n            appState.appointments.signalEntity(newAppointmentId, 'init', participants);\r\n\r\n            appState.participantsText = '';\r\n        }\r\n\r\n        render(): JSX.Element { return (<>\r\n\r\n            <AppBar position=\"static\" color=\"default\" className=\"app-bar\">\r\n                <Toolbar>\r\n\r\n                    <TextField\r\n                        fullWidth\r\n                        label=\"Comma-separated list of participants (or empty string to create appointment with yourself)\"\r\n                        placeholder=\"Alice, Bob, Charlie...\"\r\n                        InputLabelProps={{ shrink: true }}\r\n                        variant=\"outlined\"\r\n                        size=\"small\"\r\n                        value={appState.participantsText}\r\n                        onChange={(evt) => appState.participantsText = evt.target.value as string}\r\n                        onKeyPress={(evt) => {\r\n                            if (evt.key === 'Enter') {\r\n                                evt.preventDefault();\r\n                                this.createNewAppointment();\r\n                            }\r\n                        }}\r\n                    />\r\n\r\n                    <Box width={20} />\r\n\r\n                    <Button variant=\"contained\" color=\"default\" size=\"large\" className=\"new-appointment-button\"\r\n                        onClick={() => this.createNewAppointment()}\r\n                    >\r\n                        Create new appointment\r\n                    </Button>\r\n\r\n                    <Box width={40} />\r\n\r\n                    <AccountCircle />\r\n                    <Box width={5} />\r\n                    <Typography>{appState.userName}</Typography>\r\n\r\n                </Toolbar>\r\n            </AppBar>\r\n\r\n            <List>\r\n\r\n                {appState.appointments.items.length === 0 && (\r\n                    <Typography variant=\"h5\" className=\"empty-list-placeholder\" >\r\n                        No appointments created yet\r\n                    </Typography>\r\n                )}\r\n\r\n                {appState.appointments.items.map(appointment => (<ListItem><Paper className=\"appointment-paper\">\r\n\r\n                    <Grid container spacing={2}>\r\n\r\n                        <Grid item xs={2}>\r\n                            {appointment.status === AppointmentStatusEnum.Pending && (\r\n                                <Chip label=\"Pending\" color=\"default\" variant=\"outlined\" className=\"appointment-status-chip\" />\r\n                            )}\r\n                            {appointment.status === AppointmentStatusEnum.Accepted && (\r\n                                <Chip label=\"Everybody accepted\" color=\"primary\" variant=\"outlined\" className=\"appointment-status-chip\" />\r\n                            )}\r\n                            {appointment.status === AppointmentStatusEnum.Declined && (\r\n                                <Chip label=\"Someone declined\" color=\"secondary\" variant=\"outlined\" className=\"appointment-status-chip\" />\r\n                            )}\r\n                        </Grid>\r\n\r\n                        <Grid item xs={2}>\r\n                            <Typography className=\"participants-text\">Participants:</Typography>\r\n                        </Grid>\r\n\r\n                        <Grid item xs={5} className=\"appointment-grid-cell\">\r\n                            {Object.keys(appointment.participants).map(name => (\r\n                                <Chip label={name}\r\n                                    color={appointment.participants[name] === AppointmentStatusEnum.Accepted ? 'primary' :\r\n                                        (appointment.participants[name] === AppointmentStatusEnum.Declined ? 'secondary' : 'default')}\r\n                                    className=\"participant-chip\"\r\n                                />\r\n                            ))}\r\n                        </Grid>\r\n\r\n                        <Grid item xs={1}>\r\n                            <Button fullWidth variant=\"contained\" color=\"primary\"\r\n                                disabled={appointment.status !== AppointmentStatusEnum.Pending}\r\n                                onClick={() => appState.appointments.signalEntity(appointment.entityKey, 'respond', true)}\r\n                            >\r\n                                Accept\r\n                            </Button>\r\n                        </Grid>\r\n                        <Grid item xs={1}>\r\n                            <Button fullWidth variant=\"contained\" color=\"secondary\"\r\n                                disabled={appointment.status !== AppointmentStatusEnum.Pending}\r\n                                onClick={() => appState.appointments.signalEntity(appointment.entityKey, 'respond', false)}\r\n                            >\r\n                                Decline\r\n                            </Button>\r\n                        </Grid>\r\n                        <Grid item xs={1}>\r\n                            <Button fullWidth variant=\"contained\" color=\"default\"\r\n                                disabled={appointment.status === AppointmentStatusEnum.Pending}\r\n                                onClick={() => appState.appointments.signalEntity(appointment.entityKey, 'delete')}\r\n                            >\r\n                                Delete\r\n                            </Button>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                </Paper></ListItem>))}\r\n            </List>\r\n        </>);}\r\n    }\r\n);","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport { App } from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}