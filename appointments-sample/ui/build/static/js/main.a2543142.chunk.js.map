{"version":3,"sources":["shared/AppointmentState.ts","shared/common/SignalRNotifications.ts","shared/common/DurableEntityClientStateContainer.ts","common/DurableHttpClient.ts","shared/common/Constants.ts","common/EntityStateMap.ts","common/DurableEntitySet.ts","App.tsx","index.tsx"],"names":["AppointmentStatusEnum","EntityStateChangedMessage","entityName","entityKey","version","stateDiff","isEntityDestructed","msg","FormatEntityId","DurableEntityClientStateContainer","state","entityId","match","exec","entityNameLowerCase","BackendBaseUri","DurableHttpClient","_configFabric","NullLogger","instance","request","url","includes","config","this","accessTokenFactory","then","accessToken","headers","fakeUserNamePromise","fakeUserName","DefaultHttpClient","EntityStateMap","_maxKnownEntityIdsToPersist","States","LocalStorageKnownIdsKey","Object","assign","stateContainer","localStorage","entityIds","keys","slice","setItem","JSON","stringify","entityIdsJson","getItem","parse","filter","id","GetEntityNameAndKey","removeItem","DurableEntitySet","_entityNameLowerCase","attachToAll","items","toLowerCase","makeObservable","observable","attachAllEntities","initSignalR","EntitySets","fetchAndApplyKnownEntityStates","fetchAndApplyAllEntityStates","EntityStates","getState","attachEntity","undefined","createEntity","signalName","argument","signalEntity","callEntity","metadata","updateEntityMetadata","initialState","existingEntity","makeAutoObservable","fetchAndApplyEntityState","uri","HttpClient","post","content","Promise","resolve","reject","response","correlationId","SignalResultPromises","Config","logger","entityState","entitySet","push","i","length","splice","desiredVersion","retryCount","currentEntityState","get","Error","applyStateChangesFrom","entityAdded","addOrUpdateState","catch","err","MaxRetryCount","setTimeout","RetryBaseIntervalMs","log","LogLevel","existingEntityStates","getStatesCopy","item","existingStateContainer","Information","deletedEntityId","removeState","nameAndKey","entityDeleted","getStoredEntityIds","stateContainers","Warning","removeStoredEntityIds","GetEntityId","Trace","expectedVersion","rfc6902","responsePromise","errorMessage","result","SignalRConn","HubConnectionBuilder","withUrl","httpClient","build","on","entityStateChangedMessageHandler","entitySignalResponseHandler","onclose","reconnectToSignalR","start","SignalRReconnectIntervalInMs","incomingEntityState","diff","DefaultMaxKnownEntityIdsToPersist","maxKnownEntityIdsToPersist","setup","l","console","fetch","r","json","appState","userName","user_id","prompt","participantsText","inProgress","appointments","finally","App","observer","participants","split","map","p","trim","newAppointmentId","Date","toISOString","alert","message","AppBar","position","color","className","Toolbar","TextField","fullWidth","label","placeholder","InputLabelProps","shrink","variant","size","value","disabled","onChange","evt","target","onKeyPress","key","preventDefault","createNewAppointment","Box","width","Button","onClick","AccountCircle","Typography","LinearProgress","height","List","appointment","ListItem","Paper","Grid","container","spacing","xs","status","Pending","Chip","Accepted","Declined","name","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.a2543142.chunk.js","sourcesContent":["\r\nexport enum AppointmentStatusEnum {\r\n    Pending = 0,\r\n    Accepted,\r\n    Declined\r\n}\r\n\r\n// Appointment state\r\nexport class AppointmentState\r\n{\r\n    participants: { [name: string]: AppointmentStatusEnum } = {};\r\n    status: AppointmentStatusEnum = AppointmentStatusEnum.Pending;\r\n}","import * as rfc6902 from 'rfc6902';\r\n\r\nexport class EntityStateChangedMessage {\r\n    \r\n    entityName: string = '';\r\n    entityKey: string = '';\r\n    version: number = 0;\r\n    stateDiff: rfc6902.Operation[] = [];\r\n    isEntityDestructed: boolean = false;\r\n\r\n    static GetEntityId(msg: EntityStateChangedMessage): string {\r\n        return EntityStateChangedMessage.FormatEntityId(msg.entityName, msg.entityKey);\r\n    }\r\n\r\n    static FormatEntityId(entityName: string, entityKey: string): string {\r\n        return `@${entityName}@${entityKey}`;\r\n    }\r\n}\r\n\r\nexport class EntitySignalResponseMessage {\r\n\r\n    entityName: string = '';\r\n    entityKey: string = '';\r\n    correlationId: string = '';\r\n    result: any;\r\n    errorMessage: string = '';\r\n}","\r\n// A client-side wrapper around entity's state, with some extra metadata added\r\nexport class DurableEntityClientStateContainer {\r\n\r\n    version: number = 0;\r\n    state: object = {};\r\n\r\n    // Helper method for parsing entityIds\r\n    public static GetEntityNameAndKey(entityId: string): { entityNameLowerCase: string, entityKey: string } {\r\n        \r\n        const match = /@([^@]+)@(.+)/.exec(entityId);\r\n        return { entityNameLowerCase: !match ? '' : match[1], entityKey: !match ? '' : match[2] };\r\n    }\r\n}","import { DefaultHttpClient, HttpRequest, HttpResponse, NullLogger } from '@aspnet/signalr';\r\n\r\nimport { IDurableEntitySetConfig } from './IDurableEntitySetConfig';\r\nimport { ClientPrincipalHeaderName } from '../shared/common/Constants';\r\n\r\nexport const BackendBaseUri = '/a/p/i';\r\n\r\n// Custom HttpClient implementation for the purposes of DurableEntitySet\r\nexport class DurableHttpClient extends DefaultHttpClient {\r\n\r\n    constructor(private _configFabric: () => IDurableEntitySetConfig) {\r\n        super(NullLogger.instance);\r\n    }\r\n\r\n    send(request: HttpRequest): Promise<HttpResponse> {\r\n\r\n        // Applying custom config settings, but only when calling our backend\r\n\r\n        if (request.url!.includes(BackendBaseUri)) {\r\n\r\n            const config = this._configFabric();\r\n\r\n            if (!!config.accessTokenFactory) {\r\n                return config.accessTokenFactory().then(accessToken => {\r\n\r\n                    request.headers = {}\r\n                    request.headers['Authorization'] = 'Bearer ' + accessToken;\r\n\r\n                    return super.send(request);\r\n                });\r\n            }\r\n\r\n            if (!!config.fakeUserNamePromise) {\r\n                return config.fakeUserNamePromise.then(fakeUserName => {\r\n\r\n                    if (!!fakeUserName) {\r\n                        request.headers = {}\r\n                        request.headers[ClientPrincipalHeaderName] = fakeUserName;\r\n                    }\r\n\r\n                    return super.send(request);\r\n                });\r\n            }\r\n        }\r\n\r\n        return super.send(request);\r\n    }\r\n}\r\n","\r\nexport const SignalRClientHandlerName = \"entity-state-changed\";\r\n\r\nexport const SignalRSignalResponseHandlerName = \"entity-signal-response\";\r\n\r\nexport const ClientPrincipalHeaderName = 'x-ms-client-principal-name';\r\n\r\nexport const UpdateMetadataServiceMethodName = \"$update-entity-internal-metadata\";\r\n","import { DurableEntityClientStateContainer } from '../shared/common/DurableEntityClientStateContainer';\r\n\r\n// Map-like storage for all known entity states\r\nexport class EntityStateMap {\r\n\r\n    constructor(private _maxKnownEntityIdsToPersist: () => number) {\r\n    }\r\n\r\n    public getState(entityId: string): DurableEntityClientStateContainer {\r\n        return this.States[entityId];\r\n    }\r\n\r\n    public getStatesCopy(): { [entityId: string]: DurableEntityClientStateContainer } {\r\n        return Object.assign({}, this.States);\r\n    }\r\n\r\n    public addOrUpdateState(entityId: string, stateContainer: DurableEntityClientStateContainer): void {\r\n        this.States[entityId] = stateContainer;\r\n\r\n        if (!!localStorage) {\r\n\r\n            const entityIds = Object.keys(this.States).slice(0, this._maxKnownEntityIdsToPersist());\r\n            localStorage.setItem(this.LocalStorageKnownIdsKey, JSON.stringify(entityIds));\r\n        }\r\n    }\r\n\r\n    public removeState(entityId: string): void {\r\n        delete this.States[entityId];\r\n\r\n        if (!!localStorage) {\r\n\r\n            const entityIds = Object.keys(this.States).slice(0, this._maxKnownEntityIdsToPersist());\r\n            localStorage.setItem(this.LocalStorageKnownIdsKey, JSON.stringify(entityIds));\r\n        }\r\n    }\r\n\r\n    public getStoredEntityIds(entityNameLowerCase: string): string[] {\r\n\r\n        if (!localStorage) {\r\n            return [];\r\n        }\r\n\r\n        const entityIdsJson = localStorage.getItem(this.LocalStorageKnownIdsKey);\r\n        if (!entityIdsJson) {\r\n            return [];\r\n        }\r\n\r\n        return (JSON.parse(entityIdsJson) as string[])\r\n            .filter(id => DurableEntityClientStateContainer.GetEntityNameAndKey(id).entityNameLowerCase === entityNameLowerCase);\r\n    }\r\n\r\n    public removeStoredEntityIds(entityNameLowerCase: string): void {\r\n        if (!!localStorage) {\r\n            localStorage.removeItem(this.LocalStorageKnownIdsKey);\r\n        }\r\n    }\r\n\r\n    private States: { [entityId: string]: DurableEntityClientStateContainer } = {};\r\n    private readonly LocalStorageKnownIdsKey = 'DurableEntitySetKnownEntityIds';\r\n}","import { makeAutoObservable, makeObservable, observable } from 'mobx';\r\nimport { HubConnectionBuilder, HubConnection, NullLogger, LogLevel } from '@aspnet/signalr';\r\nimport * as rfc6902 from 'rfc6902';\r\n\r\nimport { ISetEntityMetadataRequest } from '../shared/common/ISetEntityMetadataRequest';\r\nimport { EntityStateChangedMessage, EntitySignalResponseMessage } from '../shared/common/SignalRNotifications';\r\nimport { SignalRClientHandlerName, SignalRSignalResponseHandlerName, UpdateMetadataServiceMethodName } from '../shared/common/Constants';\r\nimport { DurableEntityClientStateContainer } from '../shared/common/DurableEntityClientStateContainer';\r\nimport { IDurableEntitySetConfig } from './IDurableEntitySetConfig';\r\nimport { DurableHttpClient, BackendBaseUri } from './DurableHttpClient';\r\nimport { EntityStateMap } from './EntityStateMap';\r\n\r\nexport type EntityStateWithKey = { entityKey: string };\r\n\r\n// Client-side container for Durable Entities\r\nexport class DurableEntitySet<TState extends object> {\r\n\r\n    // All attached entities will appear in this observable array\r\n    items: (TState & EntityStateWithKey)[] = [];\r\n    \r\n    constructor(private _entityNameLowerCase: string, attachToAll: boolean = true) {\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        this._entityNameLowerCase = this._entityNameLowerCase.toLowerCase();\r\n\r\n        makeObservable(this, { items: observable });\r\n        \r\n        if (attachToAll) {\r\n            this.attachAllEntities();\r\n        }\r\n    }\r\n\r\n    // Attach all entities of this type (that type you previously passed to ctor).\r\n    // Preloads all existing entities of this type and then automatically captures all newly created entities.\r\n    attachAllEntities(): Promise<void> {\r\n\r\n        DurableEntitySet.initSignalR();\r\n\r\n        // Registering ourselves as listeners for this type of entity\r\n        DurableEntitySet.EntitySets[this._entityNameLowerCase] = this.items;\r\n\r\n        // First trying to fetch states for stored entityIds\r\n        return DurableEntitySet.fetchAndApplyKnownEntityStates(this._entityNameLowerCase)\r\n            // Then still always doing a mass-load, because some entities might be added/removed during the offline period\r\n            .then(() => DurableEntitySet.fetchAndApplyAllEntityStates(this._entityNameLowerCase));\r\n    }\r\n\r\n    // Manually attach a single entity with specific key\r\n    attachEntity(entityKey: string): void {\r\n\r\n        const entityId = EntityStateChangedMessage.FormatEntityId(this._entityNameLowerCase, entityKey);\r\n\r\n        if (!!DurableEntitySet.EntityStates.getState(entityId)) {\r\n            return;\r\n        }\r\n\r\n        // Registering ourselves as listeners for this particular entity\r\n        DurableEntitySet.EntitySets[entityId] = this.items;\r\n        \r\n        DurableEntitySet.attachEntity(this._entityNameLowerCase, entityKey, undefined as any);\r\n    }\r\n\r\n    // Creates (or fetches existing) an entity\r\n    createEntity(entityKey: string): void {\r\n\r\n        DurableEntitySet.createEntity(this._entityNameLowerCase, entityKey, undefined as any);\r\n    }\r\n\r\n    // Sends a signal to the given entity\r\n    signalEntity(entityKey: string, signalName: string, argument?: any): Promise<void> {\r\n\r\n        return DurableEntitySet.signalEntity(this._entityNameLowerCase, entityKey, signalName, argument);\r\n    }\r\n\r\n    // Sends a signal to the given entity and returns a promise with results\r\n    callEntity(entityKey: string, signalName: string, argument?: any): Promise<any> {\r\n\r\n        return DurableEntitySet.callEntity(this._entityNameLowerCase, entityKey, signalName, argument);\r\n    }\r\n\r\n    // Updates metadata of the given entity\r\n    updateEntityMetadata(entityKey: string, metadata: ISetEntityMetadataRequest): Promise<void> {\r\n\r\n        return DurableEntitySet.updateEntityMetadata(this._entityNameLowerCase, entityKey, metadata);\r\n    }\r\n\r\n    // Produces a single observable state instance for an existing entity\r\n    static attachEntity<TState extends object>(entityName: string, entityKey: string, initialState: TState): TState {\r\n\r\n        DurableEntitySet.initSignalR();\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        const entityNameLowerCase = entityName.toLowerCase();\r\n\r\n        const existingEntity = this.EntityStates.getState(EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey));\r\n        if (!!existingEntity) {\r\n            // If it is a known entity, then just returning it\r\n            return existingEntity.state as TState;\r\n        }\r\n\r\n        if (!!initialState) {\r\n            makeAutoObservable(initialState);\r\n        }\r\n\r\n        // Try to asynchronously retrieve the state from server\r\n        this.fetchAndApplyEntityState(entityNameLowerCase, entityKey, 0, 0, initialState);\r\n\r\n        return initialState;\r\n    }\r\n\r\n    // Creates (or fetches existing) and produces a single observable state instance for a newly created entity\r\n    static createEntity<TState extends object>(entityName: string, entityKey: string, initialState: TState): TState {\r\n\r\n        // This empty request will create the entity, if it doesn't exist yet.\r\n        this.updateEntityMetadata(entityName, entityKey, {});\r\n\r\n        return this.attachEntity(entityName, entityKey, initialState);\r\n    }\r\n\r\n    // Sends a signal to the given entity\r\n    static signalEntity(entityName: string, entityKey: string, signalName: string, argument?: any): Promise<void> {\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        const entityNameLowerCase = entityName.toLowerCase();\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityNameLowerCase}/${entityKey}/${signalName}`;\r\n        return this.HttpClient.post(uri, { content: JSON.stringify(argument) }).then();\r\n    }\r\n\r\n    // Sends a signal to the given entity and returns a promise with results\r\n    static callEntity(entityName: string, entityKey: string, signalName: string, argument?: any): Promise<any> {\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        const entityNameLowerCase = entityName.toLowerCase();\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityNameLowerCase}/${entityKey}/${signalName}`;\r\n\r\n        return new Promise<any>((resolve, reject) => {\r\n\r\n            this.HttpClient.post(uri, { content: JSON.stringify(argument) }).then(response => {\r\n\r\n                const correlationId: string = JSON.parse(response.content as string).correlationId;\r\n                this.SignalResultPromises[correlationId] = { resolve, reject };\r\n\r\n            }, reject);\r\n        });\r\n    }\r\n\r\n    // Updates metadata of the given entity\r\n    static updateEntityMetadata(entityName: string, entityKey: string, metadata: ISetEntityMetadataRequest): Promise<void> {\r\n\r\n        return this.signalEntity(entityName, entityKey, UpdateMetadataServiceMethodName, metadata);\r\n    }\r\n\r\n    // Optionally setup with these optional settings\r\n    static setup(config: IDurableEntitySetConfig): void {\r\n        this.Config = config;\r\n        if (!this.Config.logger) {\r\n            this.Config.logger = NullLogger.instance;\r\n        }\r\n    }\r\n\r\n    private static Config: IDurableEntitySetConfig = { logger: NullLogger.instance };\r\n    private static HttpClient: DurableHttpClient = new DurableHttpClient(() => DurableEntitySet.Config);\r\n    private static EntitySets: { [entityName: string]: EntityStateWithKey[] } = {};\r\n    private static SignalResultPromises: { [correlationId: string]: { resolve: (res: any) => void, reject: (err: Error) => void } } = {};\r\n\r\n    private static SignalRConn: HubConnection;\r\n\r\n    private static readonly SignalRReconnectIntervalInMs = 5000;\r\n    private static readonly MaxRetryCount = 6;\r\n    private static readonly RetryBaseIntervalMs = 500;\r\n    private static readonly DefaultMaxKnownEntityIdsToPersist = 100;\r\n\r\n    private static EntityStates = new EntityStateMap(() =>\r\n        DurableEntitySet.Config.maxKnownEntityIdsToPersist === undefined ?\r\n            DurableEntitySet.DefaultMaxKnownEntityIdsToPersist :\r\n            DurableEntitySet.Config.maxKnownEntityIdsToPersist\r\n    );\r\n\r\n    private static entityAdded(entityNameLowerCase: string, entityKey: string, entityState: EntityStateWithKey) {\r\n\r\n        const entityId = EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey);\r\n\r\n        // Searching for entitySet either for this particular entity or for this type of entity\r\n        var entitySet = this.EntitySets[entityId];\r\n        if (!entitySet) {\r\n            entitySet = this.EntitySets[entityNameLowerCase];\r\n        } else {\r\n            delete this.EntitySets[entityId];\r\n        }\r\n\r\n        if (!entitySet) {\r\n            return;\r\n        }\r\n\r\n        // Adding the entityKey property to the state object, to allow binding commands\r\n        entityState.entityKey = entityKey;\r\n        entitySet.push(entityState);\r\n    }\r\n\r\n    private static entityDeleted(entityNameLowerCase: string, entityKey: string) {\r\n\r\n        const entitySet = this.EntitySets[entityNameLowerCase];\r\n        if (!entitySet) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < entitySet.length; i++) {\r\n\r\n            if (entitySet[i].entityKey === entityKey) {\r\n                entitySet.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static fetchAndApplyEntityState(entityNameLowerCase: string, entityKey: string, desiredVersion: number, retryCount: number, currentEntityState: any = null): void {\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityNameLowerCase}/${entityKey}`;\r\n        this.HttpClient.get(uri).then(response => {\r\n\r\n            const stateContainer = JSON.parse(response.content as string) as DurableEntityClientStateContainer;\r\n            const entityId = EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey);\r\n\r\n            if (!!desiredVersion && (stateContainer.version < desiredVersion)) {\r\n                throw new Error(`Expected ${entityId} of version ${desiredVersion}, but got version ${stateContainer.version}`);\r\n            }\r\n\r\n            if (!currentEntityState) {\r\n\r\n                // If there is no existing state, then using the newly arrived state object\r\n                currentEntityState = stateContainer.state;\r\n                makeAutoObservable(currentEntityState);\r\n                \r\n            } else {\r\n\r\n                // Otherwise applying the change to the existing object, so that UI is re-rendered\r\n                this.applyStateChangesFrom(currentEntityState, stateContainer.state);\r\n            }\r\n\r\n            if (!this.EntityStates.getState(entityId)) {\r\n                \r\n                // Adding the newly-arrived state into collections, if any\r\n                this.entityAdded(entityNameLowerCase, entityKey, currentEntityState);\r\n            }\r\n\r\n            // (Re)registering this entity\r\n            this.EntityStates.addOrUpdateState(entityId, { state: currentEntityState, version: stateContainer.version });\r\n\r\n        }).catch(err => {\r\n\r\n            if (retryCount < this.MaxRetryCount) {\r\n\r\n                // Retrying\r\n                retryCount++;\r\n                setTimeout(() => {\r\n\r\n                    this.fetchAndApplyEntityState(entityNameLowerCase, entityKey, desiredVersion, retryCount, currentEntityState);\r\n\r\n                }, retryCount * this.RetryBaseIntervalMs);\r\n                \r\n            } else {\r\n\r\n                this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to fetch entity state: ${err}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    private static fetchAndApplyAllEntityStates(entityNameLowerCase: string): Promise<void> {\r\n\r\n        // Making a shallow copy of current known states BEFORE triggering a call, \r\n        // so that if any entity is removed during the call, it doesn't re-appear.\r\n        const existingEntityStates = this.EntityStates.getStatesCopy();\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityNameLowerCase}`;\r\n        return this.HttpClient.get(uri).then(response => {\r\n\r\n            for (var item of JSON.parse(response.content as string)) {\r\n\r\n                const entityKey = item.entityKey;\r\n                const entityId = EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey);\r\n                const stateContainer = item as DurableEntityClientStateContainer;\r\n\r\n                const existingStateContainer = existingEntityStates[entityId];\r\n                delete existingEntityStates[entityId];\r\n\r\n                if (!existingStateContainer) {\r\n\r\n                    makeAutoObservable(stateContainer.state);\r\n                    this.EntityStates.addOrUpdateState(entityId, stateContainer);\r\n\r\n                    // Adding the newly-arrived state into collections, if any\r\n                    this.entityAdded(entityNameLowerCase, entityKey, stateContainer.state as any);\r\n                    \r\n\r\n                } else if (existingStateContainer.version < stateContainer.version) {\r\n\r\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: ${entityId}, local version ${existingStateContainer.version}, remote version ${stateContainer.version}. State was updated.`);\r\n\r\n                    // Otherwise applying the change to the existing object, so that UI is re-rendered\r\n                    this.applyStateChangesFrom(existingStateContainer.state, stateContainer.state);\r\n                    existingStateContainer.version = stateContainer.version;\r\n\r\n                } else {\r\n\r\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: ${entityId} is already known and is up to date. Skipping.`);\r\n                }\r\n            }\r\n\r\n            // Dropping instances that might have appeared up to this point\r\n            for (const deletedEntityId in existingEntityStates) {\r\n\r\n                this.EntityStates.removeState(deletedEntityId);\r\n                const nameAndKey = DurableEntityClientStateContainer.GetEntityNameAndKey(deletedEntityId);\r\n                this.entityDeleted(nameAndKey.entityNameLowerCase, nameAndKey.entityKey);\r\n            }\r\n\r\n        }).catch(err => {\r\n            this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to fetch entity states: ${err}`);\r\n        });\r\n    }\r\n\r\n    private static fetchAndApplyKnownEntityStates(entityNameLowerCase: string): Promise<void> {\r\n\r\n        const entityIds = this.EntityStates.getStoredEntityIds(entityNameLowerCase);\r\n\r\n        // Making a shallow copy of current known states BEFORE triggering a call, \r\n        // so that if any entity is removed during the call, it doesn't re-appear.\r\n        const existingEntityStates = this.EntityStates.getStatesCopy();\r\n\r\n        const uri = `${BackendBaseUri}/entities`;\r\n        return this.HttpClient.post(uri, { content: JSON.stringify(entityIds) }).then(response => {\r\n\r\n            const stateContainers = JSON.parse(response.content as string) as DurableEntityClientStateContainer[];\r\n\r\n            for (var i = 0; i < entityIds.length; i++) {\r\n\r\n                const entityId = entityIds[i];\r\n                const nameAndKey = DurableEntityClientStateContainer.GetEntityNameAndKey(entityId);\r\n                const stateContainer = stateContainers[i];\r\n\r\n                const existingStateContainer = existingEntityStates[entityId];\r\n                if (!existingStateContainer) {\r\n\r\n                    makeAutoObservable(stateContainer.state);\r\n                    this.EntityStates.addOrUpdateState(entityId, stateContainer);\r\n\r\n                    // Adding the newly-arrived state into collections, if any\r\n                    this.entityAdded(nameAndKey.entityNameLowerCase, nameAndKey.entityKey, stateContainer.state as any);\r\n                    \r\n\r\n                } else if (existingStateContainer.version < stateContainer.version) {\r\n\r\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: ${entityId}, local version ${existingStateContainer.version}, remote version ${stateContainer.version}. State was updated.`);\r\n\r\n                    // Otherwise applying the change to the existing object, so that UI is re-rendered\r\n                    this.applyStateChangesFrom(existingStateContainer.state, stateContainer.state);\r\n                    existingStateContainer.version = stateContainer.version;\r\n\r\n                } else {\r\n\r\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: ${entityId} is already known and is up to date. Skipping.`);\r\n                }\r\n            }\r\n\r\n        }).catch(err => {\r\n\r\n            this.Config.logger!.log(LogLevel.Warning, `DurableEntitySet: failed to fetch known entity states: ${err}`);\r\n\r\n            // In most cases this error indicates, that our stored entityIds are no longer valid, so we'd better drop them\r\n            this.EntityStates.removeStoredEntityIds(entityNameLowerCase);\r\n        });\r\n    }\r\n    \r\n    private static entityStateChangedMessageHandler(msg: EntityStateChangedMessage): void {\r\n\r\n        const entityId = EntityStateChangedMessage.GetEntityId(msg);\r\n\r\n        this.Config.logger!.log(LogLevel.Trace, `DurableEntitySet: ${entityId} changed to version ${msg.version}`);\r\n\r\n        const existingStateContainer = this.EntityStates.getState(entityId);\r\n        if (msg.isEntityDestructed) {\r\n\r\n            this.EntityStates.removeState(entityId);\r\n\r\n            this.entityDeleted(msg.entityName, msg.entityKey);\r\n\r\n        } else if (!existingStateContainer) {\r\n\r\n            // If anybody is attached to this entity or this type of entity\r\n            if (!!this.EntitySets[entityId] || !!this.EntitySets[msg.entityName]) {\r\n                \r\n                // This entity is not known to us yet, so just trying to fetch its state from server\r\n                setTimeout(() => this.fetchAndApplyEntityState(msg.entityName, msg.entityKey, msg.version, 0), this.RetryBaseIntervalMs);\r\n            }\r\n           \r\n        } else {\r\n\r\n            const expectedVersion = existingStateContainer.version + 1;\r\n            if (msg.version > expectedVersion) {\r\n                \r\n                // Missed some updates, so now need to reload the state from server\r\n                this.fetchAndApplyEntityState(msg.entityName, msg.entityKey, msg.version, 0, existingStateContainer.state);\r\n\r\n            } else if (msg.version === expectedVersion) {\r\n\r\n                // Applying the change\r\n                rfc6902.applyPatch(existingStateContainer.state, msg.stateDiff);\r\n                existingStateContainer.version = msg.version;\r\n            }            \r\n        }\r\n    }\r\n\r\n    private static entitySignalResponseHandler(msg: EntitySignalResponseMessage): void {\r\n\r\n        const responsePromise = this.SignalResultPromises[msg.correlationId];\r\n        if (!responsePromise) {\r\n            return;\r\n        }\r\n\r\n        if (!msg.errorMessage) {\r\n            responsePromise.resolve(msg.result);\r\n        } else {\r\n            responsePromise.reject(new Error(msg.errorMessage));\r\n        }\r\n\r\n        delete this.SignalResultPromises[msg.correlationId];\r\n    }\r\n\r\n    private static initSignalR(): void {\r\n\r\n        if (!!this.SignalRConn) {\r\n            return;\r\n        }\r\n\r\n        // Configuring SignalR\r\n        this.SignalRConn = new HubConnectionBuilder()\r\n            .withUrl(`${BackendBaseUri}`, { httpClient: this.HttpClient, logger: this.Config.logger })\r\n            .build();\r\n\r\n        // Mounting event handlers\r\n        this.SignalRConn.on(SignalRClientHandlerName, msg => this.entityStateChangedMessageHandler(msg));\r\n        this.SignalRConn.on(SignalRSignalResponseHandlerName, msg => this.entitySignalResponseHandler(msg));\r\n\r\n        // Background reconnects are essential here. That's because in 'Default' or 'Classic' service mode\r\n        // clients get forcibly disconnected, when your backend restarts.\r\n        this.SignalRConn.onclose(() => this.reconnectToSignalR());\r\n\r\n        // Establishing SignalR connection\r\n        this.SignalRConn.start().then(\r\n            () => {\r\n                this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: successfully connected to SignalR`);\r\n            }, err => {\r\n                this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to connect to SignalR: ${err}`);\r\n            });\r\n    }\r\n\r\n    private static reconnectToSignalR() {\r\n\r\n        this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: reconnecting to SignalR...`);\r\n        this.SignalRConn.start().then(() => {\r\n            this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: reconnected to SignalR`);\r\n        }, () => {\r\n            setTimeout(() => this.reconnectToSignalR(), this.SignalRReconnectIntervalInMs);\r\n        });\r\n    }\r\n\r\n    // Applies incoming changes to an existing observable object so, that UI is re-rendered\r\n    private static applyStateChangesFrom(currentEntityState: any, incomingEntityState: any): void {\r\n\r\n        // Need to preserve the entityKey field, if it is set\r\n        incomingEntityState.entityKey = currentEntityState.entityKey;\r\n\r\n        const diff = rfc6902.createPatch(currentEntityState, incomingEntityState);\r\n        rfc6902.applyPatch(currentEntityState, diff);\r\n    }\r\n}\r\n","import React from 'react';\r\nimport { makeAutoObservable } from 'mobx';\r\nimport { observer } from 'mobx-react';\r\nimport { AppBar, Button, Box, Chip, Grid, LinearProgress, List, ListItem, Paper, TextField, Toolbar, Typography } from '@material-ui/core';\r\nimport { AccountCircle } from '@material-ui/icons';\r\n\r\nimport { DurableEntitySet } from './common/DurableEntitySet';\r\nimport { AppointmentState, AppointmentStatusEnum } from './shared/AppointmentState';\r\n\r\n// Setting up DurableEntitySet\r\nDurableEntitySet.setup({\r\n    logger: { log: (l, msg: string) => console.log(msg) },\r\n\r\n    fakeUserNamePromise: new Promise<string | null>((resolve) => {\r\n\r\n        // Trying to fetch current user name from server - this should work when deployed to Azure and EasyAuth properly configured\r\n        fetch('/.auth/me').then(r => r.json()).then(result => {\r\n\r\n            if (!result || !result.length) {\r\n                throw new Error('EasyAuth seems to be not configured. Falling back to a fake user name');\r\n            }\r\n\r\n            appState.userName = result[0].user_id;\r\n\r\n            // By returning null here we tell DurableEntitySet to proceed with using EasyAuth\r\n            resolve(null);\r\n\r\n        }).catch(() => {\r\n\r\n            // Asking the user for some fake user name. Obviously, we should never do it like that in production.\r\n            appState.userName = prompt('Enter your name:', 'Anonymous') as string;\r\n            resolve(appState.userName);\r\n        });\r\n    })\r\n});\r\n\r\n// App state container\r\nconst appState = makeAutoObservable({\r\n    userName: '',\r\n\r\n    participantsText: '',\r\n\r\n    inProgress: true,\r\n\r\n    // Here all appointment entities will appear\r\n    appointments: new DurableEntitySet<AppointmentState>('AppointmentEntity', false)\r\n});\r\n\r\n// Triggering initial load and handling its finish\r\nappState.appointments.attachAllEntities().finally(() => { appState.inProgress = false; });\r\n\r\n// Rendering that entity state\r\nexport const App = observer(\r\n    class App extends React.Component {\r\n\r\n        private createNewAppointment() {\r\n\r\n            const participants = appState.participantsText\r\n                .split(',')\r\n                .map(p => p.trim())\r\n                .filter(p => !!p);\r\n\r\n            // Generating unique entity key\r\n            const newAppointmentId = 'APP-' + new Date().toISOString();\r\n\r\n            // Creating a new entity\r\n            appState.inProgress = true;\r\n            appState.appointments.callEntity(newAppointmentId, 'init', participants)\r\n                .catch(err => alert(err.message))\r\n                .finally(() => { appState.inProgress = false; });\r\n\r\n            appState.participantsText = '';\r\n        }\r\n\r\n        render(): JSX.Element { return (<>\r\n\r\n            <AppBar position=\"static\" color=\"default\" className=\"app-bar\">\r\n                <Toolbar>\r\n\r\n                    <TextField\r\n                        fullWidth\r\n                        label=\"Comma-separated list of participants (or empty string to create appointment with yourself)\"\r\n                        placeholder=\"Alice, Bob, Charlie...\"\r\n                        InputLabelProps={{ shrink: true }}\r\n                        variant=\"outlined\"\r\n                        size=\"small\"\r\n                        value={appState.participantsText}\r\n                        disabled={appState.inProgress}\r\n                        onChange={(evt) => appState.participantsText = evt.target.value as string}\r\n                        onKeyPress={(evt) => {\r\n                            if (evt.key === 'Enter') {\r\n                                evt.preventDefault();\r\n                                this.createNewAppointment();\r\n                            }\r\n                        }}\r\n                    />\r\n\r\n                    <Box width={20} />\r\n\r\n                    <Button variant=\"contained\" color=\"default\" size=\"large\" className=\"new-appointment-button\"\r\n                        disabled={appState.inProgress}\r\n                        onClick={() => this.createNewAppointment()}\r\n                    >\r\n                        Create new appointment\r\n                    </Button>\r\n\r\n                    <Box width={40} />\r\n\r\n                    <AccountCircle />\r\n                    <Box width={5} />\r\n                    <Typography>{appState.userName}</Typography>\r\n\r\n                </Toolbar>\r\n            </AppBar>\r\n\r\n            {appState.inProgress ? (<LinearProgress />) : (<Box height={4} />)}\r\n\r\n            <List>\r\n\r\n                {appState.appointments.items.length === 0 && (\r\n                    <Typography variant=\"h5\" className=\"empty-list-placeholder\" >\r\n                        No appointments created yet\r\n                    </Typography>\r\n                )}\r\n\r\n                {appState.appointments.items.map(appointment => (<ListItem><Paper className=\"appointment-paper\">\r\n\r\n                    <Grid container spacing={2}>\r\n\r\n                        <Grid item xs={2}>\r\n                            {appointment.status === AppointmentStatusEnum.Pending && (\r\n                                <Chip label=\"Pending\" color=\"default\" variant=\"outlined\" className=\"appointment-status-chip\" />\r\n                            )}\r\n                            {appointment.status === AppointmentStatusEnum.Accepted && (\r\n                                <Chip label=\"Everybody accepted\" color=\"primary\" variant=\"outlined\" className=\"appointment-status-chip\" />\r\n                            )}\r\n                            {appointment.status === AppointmentStatusEnum.Declined && (\r\n                                <Chip label=\"Someone declined\" color=\"secondary\" variant=\"outlined\" className=\"appointment-status-chip\" />\r\n                            )}\r\n                        </Grid>\r\n\r\n                        <Grid item xs={2}>\r\n                            <Typography className=\"participants-text\">Participants:</Typography>\r\n                        </Grid>\r\n\r\n                        <Grid item xs={5} className=\"appointment-grid-cell\">\r\n                            {Object.keys(appointment.participants).map(name => (\r\n                                <Chip label={name}\r\n                                    color={appointment.participants[name] === AppointmentStatusEnum.Accepted ? 'primary' :\r\n                                        (appointment.participants[name] === AppointmentStatusEnum.Declined ? 'secondary' : 'default')}\r\n                                    className=\"participant-chip\"\r\n                                />\r\n                            ))}\r\n                        </Grid>\r\n\r\n                        <Grid item xs={1}>\r\n                            <Button fullWidth variant=\"contained\" color=\"primary\"\r\n                                disabled={appState.inProgress || appointment.status !== AppointmentStatusEnum.Pending}\r\n                                onClick={() => {\r\n                                    appState.inProgress = true;\r\n                                    appState.appointments.callEntity(appointment.entityKey, 'respond', true)\r\n                                        .catch(err => alert(err.message))\r\n                                        .finally(() => { appState.inProgress = false; });\r\n                                }}\r\n                            >\r\n                                Accept\r\n                            </Button>\r\n                        </Grid>\r\n                        <Grid item xs={1}>\r\n                            <Button fullWidth variant=\"contained\" color=\"secondary\"\r\n                                disabled={appState.inProgress || appointment.status !== AppointmentStatusEnum.Pending}\r\n                                onClick={() => {\r\n                                    appState.inProgress = true;\r\n                                    appState.appointments.callEntity(appointment.entityKey, 'respond', false)\r\n                                        .catch(err => alert(err.message))\r\n                                        .finally(() => { appState.inProgress = false; });\r\n                                }}\r\n                            >\r\n                                Decline\r\n                            </Button>\r\n                        </Grid>\r\n                        <Grid item xs={1}>\r\n                            <Button fullWidth variant=\"contained\" color=\"default\"\r\n                                disabled={appState.inProgress || appointment.status === AppointmentStatusEnum.Pending}\r\n                                onClick={() => {\r\n                                    appState.inProgress = true;\r\n                                    appState.appointments.callEntity(appointment.entityKey, 'delete')\r\n                                        .catch(err => alert(err.message))\r\n                                        .finally(() => { appState.inProgress = false; });\r\n                                }}\r\n                            >\r\n                                Delete\r\n                            </Button>\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                </Paper></ListItem>))}\r\n            </List>\r\n        </>);}\r\n    }\r\n);","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport { App } from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}