{"version":3,"sources":["shared/common/SignalRNotifications.ts","common/DurableHttpClient.ts","shared/common/Constants.ts","common/DurableEntitySet.ts","MapControl.tsx","App.tsx","index.tsx"],"names":["EntityStateChangedMessage","entityName","entityKey","version","stateDiff","isEntityDestructed","msg","FormatEntityId","BackendBaseUri","DurableHttpClient","_configFabric","NullLogger","instance","request","url","includes","config","this","accessTokenFactory","then","accessToken","headers","fakeUserNamePromise","fakeUserName","DefaultHttpClient","DurableEntitySet","_entityNameLowerCase","attachToAll","items","toLowerCase","makeObservable","observable","attachAllEntities","initSignalR","EntitySets","storedEntityIds","getStoredEntityIds","length","MaxEntitiesToLoadIndividually","fetchAndApplyAllEntityStates","individualPromises","map","id","Promise","resolve","nameAndKey","GetEntityNameAndKey","tryFetchingAndApplyingEntityState","entityNameLowerCase","err","Config","logger","log","LogLevel","Warning","removeStoredEntityIds","all","entityId","getEntityState","attachEntity","undefined","createEntity","signalName","argument","signalEntity","callEntity","metadata","updateEntityMetadata","initialState","existingEntity","state","makeAutoObservable","fetchAndApplyEntityState","uri","HttpClient","post","content","JSON","stringify","reject","response","correlationId","parse","SignalResultPromises","EntityStates","Object","assign","stateContainer","doNotPersistKnownEntityIds","localStorage","setItem","LocalStorageKnownIdsKey","keys","entityIdsJson","getItem","filter","removeItem","entityState","entitySet","push","i","splice","desiredVersion","currentEntityState","get","Error","applyStateChangesFrom","entityAdded","addOrUpdateEntityState","retryCount","catch","MaxRetryCount","setTimeout","RetryBaseIntervalMs","existingEntityStates","getEntityStatesCopy","item","existingStateContainer","Information","deletedEntityId","removeEntityState","entityDeleted","GetEntityId","Trace","expectedVersion","rfc6902","responsePromise","errorMessage","result","SignalRConn","HubConnectionBuilder","withUrl","httpClient","build","on","entityStateChangedMessageHandler","entitySignalResponseHandler","onclose","reconnectToSignalR","start","SignalRReconnectIntervalInMs","match","exec","incomingEntityState","diff","MapControl","observer","atlas","props","style","language","authOptions","authType","subscriptionKey","azureMapSubscriptionKey","events","add","controls","ZoomControl","position","BottomRight","sources","dataSource","layer","LineLayer","strokeColor","strokeWidth","layers","autorun","setCamera","bounds","padding","className","React","setup","l","console","fetch","r","json","appState","userName","user_id","prompt","entities","nameText","urlText","queryText","inProgress","mapDataSources","finally","App","startTimes","points","Date","time","getTime","minTime","Math","min","AppBar","color","Toolbar","TextField","label","placeholder","InputLabelProps","shrink","variant","size","value","disabled","onChange","evt","target","Box","width","fullWidth","Button","onClick","createNewEntity","AccountCircle","Typography","LinearProgress","height","List","entity","lastValue","valueToString","ListItem","Paper","Grid","container","spacing","xs","name","InputProps","readOnly","alert","message","error","renderGraph","replaceAll","params","query","firstValue","isNaN","isConfigSettingDefined","AzureMapSubscriptionKey","Array","isArray","renderMap","renderHorizontalBars","renderLineGraph","data","p","x","y","Number","now","window","innerWidth","stackBy","xType","xDomain","margin","left","tickTotal","stringToColorCode","firstTime","curTime","nextTime","stringValue","timeDiff","top","opacity","barWidth","title","substr","orientation","DataSource","clear","Feature","LineString","BoundingBox","fromPositions","val","str","hashCode","charCodeAt","toString","startsWith","endsWith","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5367df8a.chunk.js","sourcesContent":["import * as rfc6902 from 'rfc6902';\r\n\r\nexport class EntityStateChangedMessage {\r\n    \r\n    entityName: string = '';\r\n    entityKey: string = '';\r\n    version: number = 0;\r\n    stateDiff: rfc6902.Operation[] = [];\r\n    isEntityDestructed: boolean = false;\r\n\r\n    static GetEntityId(msg: EntityStateChangedMessage): string {\r\n        return EntityStateChangedMessage.FormatEntityId(msg.entityName, msg.entityKey);\r\n    }\r\n\r\n    static FormatEntityId(entityName: string, entityKey: string): string {\r\n        return `@${entityName}@${entityKey}`;\r\n    }\r\n}\r\n\r\nexport class EntitySignalResponseMessage {\r\n\r\n    entityName: string = '';\r\n    entityKey: string = '';\r\n    correlationId: string = '';\r\n    result: any;\r\n    errorMessage: string = '';\r\n}","import { DefaultHttpClient, HttpRequest, HttpResponse, NullLogger } from '@aspnet/signalr';\r\n\r\nimport { IDurableEntitySetConfig } from './IDurableEntitySetConfig';\r\nimport { ClientPrincipalHeaderName } from '../shared/common/Constants';\r\n\r\nexport const BackendBaseUri = '/a/p/i';\r\n\r\n// Custom HttpClient implementation for the purposes of DurableEntitySet\r\nexport class DurableHttpClient extends DefaultHttpClient {\r\n\r\n    constructor(private _configFabric: () => IDurableEntitySetConfig) {\r\n        super(NullLogger.instance);\r\n    }\r\n\r\n    send(request: HttpRequest): Promise<HttpResponse> {\r\n\r\n        // Applying custom config settings, but only when calling our backend\r\n\r\n        if (request.url!.includes(BackendBaseUri)) {\r\n\r\n            const config = this._configFabric();\r\n\r\n            if (!!config.accessTokenFactory) {\r\n                return config.accessTokenFactory().then(accessToken => {\r\n\r\n                    request.headers = {}\r\n                    request.headers['Authorization'] = 'Bearer ' + accessToken;\r\n\r\n                    return super.send(request);\r\n                });\r\n            }\r\n\r\n            if (!!config.fakeUserNamePromise) {\r\n                return config.fakeUserNamePromise.then(fakeUserName => {\r\n\r\n                    if (!!fakeUserName) {\r\n                        request.headers = {}\r\n                        request.headers[ClientPrincipalHeaderName] = fakeUserName;\r\n                    }\r\n\r\n                    return super.send(request);\r\n                });\r\n            }\r\n        }\r\n\r\n        return super.send(request);\r\n    }\r\n}\r\n","\r\nexport const SignalRClientHandlerName = \"entity-state-changed\";\r\n\r\nexport const SignalRSignalResponseHandlerName = \"entity-signal-response\";\r\n\r\nexport const ClientPrincipalHeaderName = 'x-ms-client-principal-name';\r\n\r\nexport const UpdateMetadataServiceMethodName = \"$update-entity-internal-metadata\";\r\n","import { makeAutoObservable, makeObservable, observable } from 'mobx';\r\nimport { HubConnectionBuilder, HubConnection, NullLogger, LogLevel } from '@aspnet/signalr';\r\nimport * as rfc6902 from 'rfc6902';\r\n\r\nimport { ISetEntityMetadataRequest } from '../shared/common/ISetEntityMetadataRequest';\r\nimport { EntityStateChangedMessage, EntitySignalResponseMessage } from '../shared/common/SignalRNotifications';\r\nimport { SignalRClientHandlerName, SignalRSignalResponseHandlerName, UpdateMetadataServiceMethodName } from '../shared/common/Constants';\r\nimport { DurableEntityClientStateContainer } from '../shared/common/DurableEntityClientStateContainer';\r\nimport { IDurableEntitySetConfig } from './IDurableEntitySetConfig';\r\nimport { DurableHttpClient, BackendBaseUri } from './DurableHttpClient';\r\n\r\nexport type EntityStateWithKey = { entityKey: string };\r\n\r\n// Client-side container for Durable Entities\r\nexport class DurableEntitySet<TState extends object> {\r\n\r\n    // All attached entities will appear in this observable array\r\n    items: (TState & EntityStateWithKey)[] = [];\r\n    \r\n    constructor(private _entityNameLowerCase: string, attachToAll: boolean = true) {\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        this._entityNameLowerCase = this._entityNameLowerCase.toLowerCase();\r\n\r\n        makeObservable(this, { items: observable });\r\n        \r\n        if (attachToAll) {\r\n            this.attachAllEntities();\r\n        }\r\n    }\r\n\r\n    // Attach all entities of this type (that type you previously passed to ctor).\r\n    // Preloads all existing entities of this type and then automatically captures all newly created entities.\r\n    attachAllEntities(): Promise<void> {\r\n\r\n        DurableEntitySet.initSignalR();\r\n\r\n        // Registering ourselves as listeners for this type of entity\r\n        DurableEntitySet.EntitySets[this._entityNameLowerCase] = this.items;\r\n\r\n        // Trying to get cached entityIds from localStorage\r\n        const storedEntityIds = DurableEntitySet.getStoredEntityIds(this._entityNameLowerCase);\r\n\r\n        // If we have too many ids cached locally\r\n        if (storedEntityIds.length > DurableEntitySet.MaxEntitiesToLoadIndividually) {\r\n            \r\n            // Just loading all existing entities at once\r\n            return DurableEntitySet.fetchAndApplyAllEntityStates(this._entityNameLowerCase);\r\n        }\r\n\r\n        // First triggering parallel individual loads - this should be faster\r\n        const individualPromises = storedEntityIds.map(id => {\r\n\r\n            // Intentionally always resolves\r\n            return new Promise<void>((resolve) => {\r\n                const nameAndKey = DurableEntitySet.GetEntityNameAndKey(id);\r\n                DurableEntitySet\r\n                    .tryFetchingAndApplyingEntityState(nameAndKey.entityNameLowerCase, nameAndKey.entityKey, 0)\r\n                    .then(() => resolve(), (err) => {\r\n                        \r\n                        DurableEntitySet.Config.logger!.log(LogLevel.Warning, `DurableEntitySet: failed to fetch initial entity state: ${err}`);\r\n\r\n                        // In most cases this error indicates, that our stored entityIds are no longer valid, so we'd better drop them\r\n                        DurableEntitySet.removeStoredEntityIds(this._entityNameLowerCase);\r\n\r\n                        resolve();\r\n                    });\r\n            });\r\n        });\r\n\r\n        // After individual loads completed (no matter what the outcome is), still doing the normal mass-load\r\n        return Promise.all(individualPromises)\r\n            .then(() => DurableEntitySet.fetchAndApplyAllEntityStates(this._entityNameLowerCase));\r\n    }\r\n\r\n    // Manually attach a single entity with specific key\r\n    attachEntity(entityKey: string): void {\r\n\r\n        const entityId = EntityStateChangedMessage.FormatEntityId(this._entityNameLowerCase, entityKey);\r\n\r\n        if (!!DurableEntitySet.getEntityState(entityId)) {\r\n            return;\r\n        }\r\n\r\n        // Registering ourselves as listeners for this particular entity\r\n        DurableEntitySet.EntitySets[entityId] = this.items;\r\n        \r\n        DurableEntitySet.attachEntity(this._entityNameLowerCase, entityKey, undefined as any);\r\n    }\r\n\r\n    // Creates (or fetches existing) an entity\r\n    createEntity(entityKey: string): void {\r\n\r\n        DurableEntitySet.createEntity(this._entityNameLowerCase, entityKey, undefined as any);\r\n    }\r\n\r\n    // Sends a signal to the given entity\r\n    signalEntity(entityKey: string, signalName: string, argument?: any): Promise<void> {\r\n\r\n        return DurableEntitySet.signalEntity(this._entityNameLowerCase, entityKey, signalName, argument);\r\n    }\r\n\r\n    // Sends a signal to the given entity and returns a promise with results\r\n    callEntity(entityKey: string, signalName: string, argument?: any): Promise<any> {\r\n\r\n        return DurableEntitySet.callEntity(this._entityNameLowerCase, entityKey, signalName, argument);\r\n    }\r\n\r\n    // Updates metadata of the given entity\r\n    updateEntityMetadata(entityKey: string, metadata: ISetEntityMetadataRequest): Promise<void> {\r\n\r\n        return DurableEntitySet.updateEntityMetadata(this._entityNameLowerCase, entityKey, metadata);\r\n    }\r\n\r\n    // Produces a single observable state instance for an existing entity\r\n    static attachEntity<TState extends object>(entityName: string, entityKey: string, initialState: TState): TState {\r\n\r\n        DurableEntitySet.initSignalR();\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        const entityNameLowerCase = entityName.toLowerCase();\r\n\r\n        const existingEntity = this.getEntityState(EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey));\r\n        if (!!existingEntity) {\r\n            // If it is a known entity, then just returning it\r\n            return existingEntity.state as TState;\r\n        }\r\n\r\n        if (!!initialState) {\r\n            makeAutoObservable(initialState);\r\n        }\r\n\r\n        // Try to asynchronously retrieve the state from server\r\n        this.fetchAndApplyEntityState(entityNameLowerCase, entityKey, 0, 0, initialState);\r\n\r\n        return initialState;\r\n    }\r\n\r\n    // Creates (or fetches existing) and produces a single observable state instance for a newly created entity\r\n    static createEntity<TState extends object>(entityName: string, entityKey: string, initialState: TState): TState {\r\n\r\n        // This empty request will create the entity, if it doesn't exist yet.\r\n        this.updateEntityMetadata(entityName, entityKey, {});\r\n\r\n        return this.attachEntity(entityName, entityKey, initialState);\r\n    }\r\n\r\n    // Sends a signal to the given entity\r\n    static signalEntity(entityName: string, entityKey: string, signalName: string, argument?: any): Promise<void> {\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        const entityNameLowerCase = entityName.toLowerCase();\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityNameLowerCase}/${entityKey}/${signalName}`;\r\n        return this.HttpClient.post(uri, { content: JSON.stringify(argument) }).then();\r\n    }\r\n\r\n    // Sends a signal to the given entity and returns a promise with results\r\n    static callEntity(entityName: string, entityKey: string, signalName: string, argument?: any): Promise<any> {\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        const entityNameLowerCase = entityName.toLowerCase();\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityNameLowerCase}/${entityKey}/${signalName}`;\r\n\r\n        return new Promise<any>((resolve, reject) => {\r\n\r\n            this.HttpClient.post(uri, { content: JSON.stringify(argument) }).then(response => {\r\n\r\n                const correlationId: string = JSON.parse(response.content as string).correlationId;\r\n                this.SignalResultPromises[correlationId] = { resolve, reject };\r\n\r\n            }, reject);\r\n        });\r\n    }\r\n\r\n    // Updates metadata of the given entity\r\n    static updateEntityMetadata(entityName: string, entityKey: string, metadata: ISetEntityMetadataRequest): Promise<void> {\r\n\r\n        return this.signalEntity(entityName, entityKey, UpdateMetadataServiceMethodName, metadata);\r\n    }\r\n\r\n    // Optionally setup with these optional settings\r\n    static setup(config: IDurableEntitySetConfig): void {\r\n        this.Config = config;\r\n        if (!this.Config.logger) {\r\n            this.Config.logger = NullLogger.instance;\r\n        }\r\n    }\r\n\r\n    private static Config: IDurableEntitySetConfig = { logger: NullLogger.instance };\r\n    private static HttpClient: DurableHttpClient = new DurableHttpClient(() => DurableEntitySet.Config);\r\n    private static EntitySets: { [entityName: string]: EntityStateWithKey[] } = {};\r\n    private static SignalResultPromises: { [correlationId: string]: { resolve: (res: any) => void, reject: (err: Error) => void } } = {};\r\n\r\n    private static SignalRConn: HubConnection;\r\n\r\n    private static readonly SignalRReconnectIntervalInMs = 5000;\r\n    private static readonly MaxRetryCount = 6;\r\n    private static readonly RetryBaseIntervalMs = 500;\r\n    private static readonly MaxEntitiesToLoadIndividually = 50;\r\n\r\n    private static EntityStates: { [entityId: string]: DurableEntityClientStateContainer } = {};\r\n    private static readonly LocalStorageKnownIdsKey = 'DurableEntitySetKnownEntityIds';\r\n\r\n    private static getEntityState(entityId: string): DurableEntityClientStateContainer {\r\n        return this.EntityStates[entityId];\r\n    }\r\n\r\n    private static getEntityStatesCopy(): { [entityId: string]: DurableEntityClientStateContainer } {\r\n        return Object.assign({}, this.EntityStates);\r\n    }\r\n\r\n    private static addOrUpdateEntityState(entityId: string, stateContainer: DurableEntityClientStateContainer): void {\r\n        this.EntityStates[entityId] = stateContainer;\r\n\r\n        if (!this.Config.doNotPersistKnownEntityIds && !!localStorage) {\r\n            localStorage.setItem(this.LocalStorageKnownIdsKey, JSON.stringify(Object.keys(this.EntityStates)));\r\n        }\r\n    }\r\n\r\n    private static removeEntityState(entityId: string): void {\r\n        delete this.EntityStates[entityId];\r\n\r\n        if (!this.Config.doNotPersistKnownEntityIds && !!localStorage) {\r\n            localStorage.setItem(this.LocalStorageKnownIdsKey, JSON.stringify(Object.keys(this.EntityStates)));\r\n        }\r\n    }\r\n\r\n    private static getStoredEntityIds(entityNameLowerCase: string): string[] {\r\n\r\n        if (!!this.Config.doNotPersistKnownEntityIds || !localStorage) {\r\n            return [];\r\n        }\r\n\r\n        const entityIdsJson = localStorage.getItem(this.LocalStorageKnownIdsKey);\r\n        if (!entityIdsJson) {\r\n            return [];\r\n        }\r\n\r\n        return (JSON.parse(entityIdsJson) as string[])\r\n            .filter(id => this.GetEntityNameAndKey(id).entityNameLowerCase === entityNameLowerCase);\r\n    }\r\n\r\n    private static removeStoredEntityIds(entityNameLowerCase: string): void {\r\n        if (!!localStorage) {\r\n            localStorage.removeItem(this.LocalStorageKnownIdsKey);\r\n        }\r\n    }\r\n\r\n    private static entityAdded(entityNameLowerCase: string, entityKey: string, entityState: EntityStateWithKey) {\r\n\r\n        const entityId = EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey);\r\n\r\n        // Searching for entitySet either for this particular entity or for this type of entity\r\n        var entitySet = this.EntitySets[entityId];\r\n        if (!entitySet) {\r\n            entitySet = this.EntitySets[entityNameLowerCase];\r\n        } else {\r\n            delete this.EntitySets[entityId];\r\n        }\r\n\r\n        if (!entitySet) {\r\n            return;\r\n        }\r\n\r\n        // Adding the entityKey property to the state object, to allow binding commands\r\n        entityState.entityKey = entityKey;\r\n        entitySet.push(entityState);\r\n    }\r\n\r\n    private static entityDeleted(entityNameLowerCase: string, entityKey: string) {\r\n\r\n        const entitySet = this.EntitySets[entityNameLowerCase];\r\n        if (!entitySet) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < entitySet.length; i++) {\r\n\r\n            if (entitySet[i].entityKey === entityKey) {\r\n                entitySet.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static tryFetchingAndApplyingEntityState(entityNameLowerCase: string, entityKey: string, desiredVersion: number, currentEntityState: any = null): Promise<void> {\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityNameLowerCase}/${entityKey}`;\r\n        return this.HttpClient.get(uri).then(response => {\r\n\r\n            const stateContainer = JSON.parse(response.content as string) as DurableEntityClientStateContainer;\r\n            const entityId = EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey);\r\n\r\n            if (!!desiredVersion && (stateContainer.version < desiredVersion)) {\r\n                throw new Error(`Expected ${entityId} of version ${desiredVersion}, but got version ${stateContainer.version}`);\r\n            }\r\n\r\n            if (!currentEntityState) {\r\n\r\n                // If there is no existing state, then using the newly arrived state object\r\n                currentEntityState = stateContainer.state;\r\n                makeAutoObservable(currentEntityState);\r\n                \r\n            } else {\r\n\r\n                // Otherwise applying the change to the existing object, so that UI is re-rendered\r\n                this.applyStateChangesFrom(currentEntityState, stateContainer.state);\r\n            }\r\n\r\n            if (!this.getEntityState(entityId)) {\r\n                \r\n                // Adding the newly-arrived state into collections, if any\r\n                this.entityAdded(entityNameLowerCase, entityKey, currentEntityState);\r\n            }\r\n\r\n            // (Re)registering this entity\r\n            this.addOrUpdateEntityState(entityId, { state: currentEntityState, version: stateContainer.version });\r\n        });\r\n    }\r\n\r\n    private static fetchAndApplyEntityState(entityNameLowerCase: string, entityKey: string, desiredVersion: number, retryCount: number, currentEntityState: any = null): void {\r\n\r\n        this.tryFetchingAndApplyingEntityState(entityNameLowerCase, entityKey, desiredVersion, currentEntityState).catch(err => {\r\n\r\n            if (retryCount < this.MaxRetryCount) {\r\n\r\n                // Retrying\r\n                retryCount++;\r\n                setTimeout(() => {\r\n\r\n                    this.fetchAndApplyEntityState(entityNameLowerCase, entityKey, desiredVersion, retryCount, currentEntityState);\r\n\r\n                }, retryCount * this.RetryBaseIntervalMs);\r\n                \r\n            } else {\r\n\r\n                this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to fetch entity state: ${err}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    private static fetchAndApplyAllEntityStates(entityNameLowerCase: string): Promise<void> {\r\n\r\n        // Making a shallow copy of current known states BEFORE triggering a call, \r\n        // so that if any entity is removed during the call, it doesn't re-appear.\r\n        const existingEntityStates = this.getEntityStatesCopy();\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityNameLowerCase}`;\r\n        return this.HttpClient.get(uri).then(response => {\r\n\r\n            for (var item of JSON.parse(response.content as string)) {\r\n\r\n                const entityKey = item.entityKey;\r\n                const entityId = EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey);\r\n                const stateContainer = item as DurableEntityClientStateContainer;\r\n\r\n                const existingStateContainer = existingEntityStates[entityId];\r\n                delete existingEntityStates[entityId];\r\n\r\n                if (!existingStateContainer) {\r\n\r\n                    makeAutoObservable(stateContainer.state);\r\n                    this.addOrUpdateEntityState(entityId, stateContainer);\r\n\r\n                    // Adding the newly-arrived state into collections, if any\r\n                    this.entityAdded(entityNameLowerCase, entityKey, stateContainer.state as any);\r\n                    \r\n\r\n                } else if (existingStateContainer.version < stateContainer.version) {\r\n\r\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: ${entityId}, local version ${existingStateContainer.version}, remote version ${stateContainer.version}. State was updated.`);\r\n\r\n                    // Otherwise applying the change to the existing object, so that UI is re-rendered\r\n                    this.applyStateChangesFrom(existingStateContainer.state, stateContainer.state);\r\n                    existingStateContainer.version = stateContainer.version;\r\n\r\n                } else {\r\n\r\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: ${entityId} is already known and is up to date. Skipping.`);\r\n                }\r\n            }\r\n\r\n            // Dropping instances that might have appeared up to this point\r\n            for (const deletedEntityId in existingEntityStates) {\r\n\r\n                this.removeEntityState(deletedEntityId);\r\n                const nameAndKey = this.GetEntityNameAndKey(deletedEntityId);\r\n                this.entityDeleted(nameAndKey.entityNameLowerCase, nameAndKey.entityKey);\r\n            }\r\n\r\n        }).catch(err => {\r\n            this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to fetch entity states: ${err}`);\r\n        });\r\n    }\r\n\r\n    private static entityStateChangedMessageHandler(msg: EntityStateChangedMessage): void {\r\n\r\n        const entityId = EntityStateChangedMessage.GetEntityId(msg);\r\n\r\n        this.Config.logger!.log(LogLevel.Trace, `DurableEntitySet: ${entityId} changed to version ${msg.version}`);\r\n\r\n        const existingStateContainer = this.getEntityState(entityId);\r\n        if (msg.isEntityDestructed) {\r\n\r\n            this.removeEntityState(entityId);\r\n\r\n            this.entityDeleted(msg.entityName, msg.entityKey);\r\n\r\n        } else if (!existingStateContainer) {\r\n\r\n            // If anybody is attached to this entity or this type of entity\r\n            if (!!this.EntitySets[entityId] || !!this.EntitySets[msg.entityName]) {\r\n                \r\n                // This entity is not known to us yet, so just trying to fetch its state from server\r\n                setTimeout(() => this.fetchAndApplyEntityState(msg.entityName, msg.entityKey, msg.version, 0), this.RetryBaseIntervalMs);\r\n            }\r\n           \r\n        } else {\r\n\r\n            const expectedVersion = existingStateContainer.version + 1;\r\n            if (msg.version > expectedVersion) {\r\n                \r\n                // Missed some updates, so now need to reload the state from server\r\n                this.fetchAndApplyEntityState(msg.entityName, msg.entityKey, msg.version, 0, existingStateContainer.state);\r\n\r\n            } else if (msg.version === expectedVersion) {\r\n\r\n                // Applying the change\r\n                rfc6902.applyPatch(existingStateContainer.state, msg.stateDiff);\r\n                existingStateContainer.version = msg.version;\r\n            }            \r\n        }\r\n    }\r\n\r\n    private static entitySignalResponseHandler(msg: EntitySignalResponseMessage): void {\r\n\r\n        const responsePromise = this.SignalResultPromises[msg.correlationId];\r\n        if (!responsePromise) {\r\n            return;\r\n        }\r\n\r\n        if (!msg.errorMessage) {\r\n            responsePromise.resolve(msg.result);\r\n        } else {\r\n            responsePromise.reject(new Error(msg.errorMessage));\r\n        }\r\n\r\n        delete this.SignalResultPromises[msg.correlationId];\r\n    }\r\n\r\n    private static initSignalR(): void {\r\n\r\n        if (!!this.SignalRConn) {\r\n            return;\r\n        }\r\n\r\n        // Configuring SignalR\r\n        this.SignalRConn = new HubConnectionBuilder()\r\n            .withUrl(`${BackendBaseUri}`, { httpClient: this.HttpClient, logger: this.Config.logger })\r\n            .build();\r\n\r\n        // Mounting event handlers\r\n        this.SignalRConn.on(SignalRClientHandlerName, msg => this.entityStateChangedMessageHandler(msg));\r\n        this.SignalRConn.on(SignalRSignalResponseHandlerName, msg => this.entitySignalResponseHandler(msg));\r\n\r\n        // Background reconnects are essential here. That's because in 'Default' or 'Classic' service mode\r\n        // clients get forcibly disconnected, when your backend restarts.\r\n        this.SignalRConn.onclose(() => this.reconnectToSignalR());\r\n\r\n        // Establishing SignalR connection\r\n        this.SignalRConn.start().then(\r\n            () => {\r\n                this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: successfully connected to SignalR`);\r\n            }, err => {\r\n                this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to connect to SignalR: ${err}`);\r\n            });\r\n    }\r\n\r\n    private static reconnectToSignalR() {\r\n\r\n        this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: reconnecting to SignalR...`);\r\n        this.SignalRConn.start().then(() => {\r\n            this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: reconnected to SignalR`);\r\n        }, () => {\r\n            setTimeout(() => this.reconnectToSignalR(), this.SignalRReconnectIntervalInMs);\r\n        });\r\n    }\r\n\r\n    static GetEntityNameAndKey(entityId: string): { entityNameLowerCase: string, entityKey: string } {\r\n        \r\n        const match = /@([^@]+)@(.+)/.exec(entityId);\r\n        return { entityNameLowerCase: !match ? '' : match[1], entityKey: !match ? '' : match[2] };\r\n    }\r\n\r\n    // Applies incoming changes to an existing observable object so, that UI is re-rendered\r\n    private static applyStateChangesFrom(currentEntityState: any, incomingEntityState: any): void {\r\n\r\n        // Need to preserve the entityKey field, if it is set\r\n        incomingEntityState.entityKey = currentEntityState.entityKey;\r\n\r\n        const diff = rfc6902.createPatch(currentEntityState, incomingEntityState);\r\n        rfc6902.applyPatch(currentEntityState, diff);\r\n    }\r\n}","import * as React from 'react';\r\nimport { autorun } from 'mobx';\r\nimport { observer } from 'mobx-react';\r\n\r\nimport * as atlas from 'azure-maps-control';\r\n\r\n// Visualizes geo coordinates with Azure Maps control\r\nexport const MapControl = observer(class MapControl extends React.Component<{ entityKey: string, dataSource: atlas.source.DataSource, bounds: atlas.data.BoundingBox, azureMapSubscriptionKey: string }> {\r\n\r\n    componentDidMount() {\r\n\r\n        var map = new atlas.Map(this.props.entityKey, {\r\n\r\n            style: \"road_shaded_relief\",\r\n            language: 'en-US',\r\n\r\n            authOptions: {\r\n                authType: atlas.AuthenticationType.subscriptionKey,\r\n                subscriptionKey: this.props.azureMapSubscriptionKey\r\n            }\r\n        });\r\n\r\n        map.events.add('ready', () => {\r\n\r\n            // Adding the zoom control\r\n            map.controls.add( [new atlas.control.ZoomControl() ], { position: atlas.ControlPosition.BottomRight } );\r\n\r\n            // Showing the dataSource with route line\r\n            map.sources.add(this.props.dataSource);\r\n\r\n            const layer = new atlas.layer.LineLayer(this.props.dataSource, undefined, {\r\n                strokeColor: 'DarkOrchid',\r\n                strokeWidth: 3\r\n            });\r\n            map.layers.add(layer);\r\n        });\r\n\r\n        // This will zoom the map to the bounding box of all points\r\n        autorun(() => {\r\n            map.setCamera({ bounds: this.props.bounds, padding: 40 });\r\n        });\r\n    }\r\n\r\n    render(): JSX.Element {\r\n        return (<div id={this.props.entityKey} className=\"map-div\"/>);\r\n    }\r\n})","import React from 'react';\r\nimport { makeAutoObservable } from 'mobx';\r\nimport { observer } from 'mobx-react';\r\nimport { AppBar, Button, Box, Grid, LinearProgress, List, ListItem, Paper, TextField, Toolbar, Typography } from '@material-ui/core';\r\nimport { AccountCircle } from '@material-ui/icons';\r\nimport { XYPlot, XAxis, YAxis, HorizontalBarSeries, DiscreteColorLegend, LineSeries } from 'react-vis';\r\nimport * as atlas from 'azure-maps-control';\r\n\r\nimport { DurableEntitySet } from './common/DurableEntitySet';\r\nimport { TrackerState } from './shared/TrackerState';\r\nimport { ITrackerParams } from './shared/ITrackerParams';\r\nimport { MapControl } from './MapControl';\r\n\r\n// This comes from server-side config settings and is being sent to us via proxy\r\ndeclare const AzureMapSubscriptionKey: string;\r\n\r\n// Setting up DurableEntitySet\r\nDurableEntitySet.setup({\r\n    logger: { log: (l, msg: string) => console.log(msg) },\r\n\r\n    fakeUserNamePromise: new Promise<string | null>((resolve) => {\r\n\r\n        // Trying to fetch current user name from server - this should work when deployed to Azure and EasyAuth properly configured\r\n        fetch('/.auth/me').then(r => r.json()).then(result => {\r\n\r\n            if (!result || !result.length) {\r\n                throw new Error('EasyAuth seems to be not configured. Falling back to a fake user name');\r\n            }\r\n\r\n            appState.userName = result[0].user_id;\r\n\r\n            // By returning null here we tell DurableEntitySet to proceed with using EasyAuth\r\n            resolve(null);\r\n\r\n        }).catch(() => {\r\n\r\n            // Asking the user for some fake user name. Obviously, we should never do it like that in production.\r\n            appState.userName = prompt('Enter your name:', 'Anonymous') as string;\r\n            resolve(appState.userName);\r\n        });\r\n    })\r\n});\r\n\r\n// App state container\r\nconst appState = makeAutoObservable({\r\n\r\n    // Here all tracker entities will appear\r\n    entities: new DurableEntitySet<TrackerState>('TrackerEntity', false),\r\n\r\n    userName: '',\r\n    nameText: '',\r\n    urlText: '',\r\n    queryText: '',\r\n    inProgress: true,\r\n\r\n    mapDataSources: {} as { [key: string]: atlas.source.DataSource }\r\n});\r\n\r\n// Triggering initial load and handling its finish\r\nappState.entities.attachAllEntities().finally(() => { appState.inProgress = false; });\r\n\r\n// Rendering that entity state\r\nexport const App = observer(\r\n    class App extends React.Component {\r\n\r\n        render(): JSX.Element {\r\n\r\n            const startTimes = appState.entities.items\r\n                .filter(i => !!i.points.length)\r\n                .map(i => new Date(i.points[0].time).getTime());\r\n            const minTime = Math.min(...startTimes);\r\n            \r\n            return (<>\r\n\r\n                <AppBar position=\"static\" color=\"default\" className=\"app-bar\">\r\n                    <Toolbar>\r\n\r\n                        <TextField\r\n                            className=\"name-text\"\r\n                            label=\"Name\"\r\n                            placeholder=\"e.g. 'Temperature in Oslo'\"\r\n                            InputLabelProps={{ shrink: true }}\r\n                            variant=\"outlined\"\r\n                            size=\"small\"\r\n                            value={appState.nameText}\r\n                            disabled={appState.inProgress}\r\n                            onChange={(evt) => appState.nameText = evt.target.value as string}\r\n                        />\r\n\r\n                        <Box width={30} />\r\n\r\n                        <TextField\r\n                            fullWidth\r\n                            label=\"URL to track\"\r\n                            placeholder=\"e.g. 'https://api.openweathermap.org/data/2.5/weather?q=Oslo&appid={api-key}'\"\r\n                            InputLabelProps={{ shrink: true }}\r\n                            variant=\"outlined\"\r\n                            size=\"small\"\r\n                            value={appState.urlText}\r\n                            disabled={appState.inProgress}\r\n                            onChange={(evt) => appState.urlText = evt.target.value as string}\r\n                        />\r\n\r\n                        <Box width={30} />\r\n\r\n                        <TextField\r\n                            className=\"json-query-text\"\r\n                            label=\"(optional) JSON Query or Regular Expression\"\r\n                            placeholder=\"e.g. '$.main.temp'\"\r\n                            InputLabelProps={{ shrink: true }}\r\n                            variant=\"outlined\"\r\n                            size=\"small\"\r\n                            value={appState.queryText}\r\n                            disabled={appState.inProgress}\r\n                            onChange={(evt) => appState.queryText = evt.target.value as string}\r\n                        />\r\n\r\n                        <Box width={30} />\r\n\r\n                        <Button variant=\"contained\" color=\"default\" size=\"large\" className=\"new-entity-button\"\r\n                            disabled={!appState.nameText || !appState.urlText || appState.inProgress}\r\n                            onClick={() => this.createNewEntity()}\r\n                        >\r\n                            Track\r\n                        </Button>\r\n\r\n                        <Box width={40} />\r\n\r\n                        <AccountCircle />\r\n                        <Box width={5} />\r\n                        <Typography>{appState.userName}</Typography>\r\n\r\n                    </Toolbar>\r\n                </AppBar>\r\n\r\n                {appState.inProgress ? (<LinearProgress />) : (<Box height={4} />)}\r\n\r\n                <List>\r\n\r\n                    {appState.entities.items.length === 0 && (\r\n                        <Typography variant=\"h5\" className=\"empty-list-placeholder\" >\r\n                            Nothing is tracked yet\r\n                        </Typography>\r\n                    )}\r\n\r\n                    {appState.entities.items.map(entity => {\r\n\r\n                        const lastValue = !!entity.points.length ? this.valueToString(entity.points[entity.points.length - 1].value) : '';\r\n\r\n                        return (<ListItem key={entity.entityKey}><Paper className=\"entity-paper\">\r\n\r\n                            <Grid container spacing={2}>\r\n\r\n                                <Grid item xs={2}>\r\n\r\n                                    <Grid container spacing={2}>\r\n                                        <Grid item xs={12}><Typography variant=\"h6\">{entity.name}</Typography></Grid>\r\n\r\n                                        <Grid item xs={12}>\r\n                                            <TextField\r\n                                                label=\"Current Value\"\r\n                                                InputProps={{ readOnly: true }}\r\n                                                InputLabelProps={{ shrink: true }}\r\n                                                variant=\"outlined\"\r\n                                                size=\"small\"\r\n                                                fullWidth\r\n                                                value={lastValue}\r\n                                            />\r\n                                        </Grid>\r\n                                        \r\n                                        <Grid item xs={6}>\r\n                                            <Button className=\"item-btn\" variant=\"contained\" color=\"default\" size=\"small\" disabled={appState.inProgress}\r\n                                                onClick={() => {\r\n                                                    appState.inProgress = true;\r\n                                                    appState.entities.callEntity(entity.entityKey, 'reset')\r\n                                                        .catch(err => alert(err.message))\r\n                                                        .finally(() => { appState.inProgress = false; });\r\n                                                }}\r\n                                            >\r\n                                                Reset\r\n                                            </Button>\r\n                                        </Grid>\r\n\r\n                                        <Grid item xs={6}>\r\n                                            <Button className=\"item-btn\" variant=\"contained\" color=\"default\" size=\"small\" disabled={appState.inProgress}\r\n                                                onClick={() => {\r\n                                                    appState.inProgress = true;\r\n                                                    appState.entities.callEntity(entity.entityKey, 'delete')\r\n                                                        .catch(err => alert(err.message))\r\n                                                        .finally(() => { appState.inProgress = false; });\r\n                                                }}\r\n                                            >\r\n                                                Delete\r\n                                            </Button>\r\n                                        </Grid>\r\n\r\n                                        {!!entity.error && (<Grid item xs={12}>\r\n                                            <Typography color=\"secondary\" variant=\"caption\">Error: {entity.error}</Typography>\r\n                                        </Grid>)}\r\n\r\n                                    </Grid>                               \r\n                                </Grid>\r\n\r\n                                <Grid item xs={10}>\r\n\r\n                                    {this.renderGraph(entity.entityKey, entity, minTime)}\r\n\r\n                                </Grid>\r\n                            </Grid>\r\n\r\n                        </Paper></ListItem>); })\r\n                    }\r\n                </List>\r\n            </>);\r\n        }\r\n\r\n        private createNewEntity() {\r\n\r\n            // Deriving entityId from url + jsonPath\r\n            const entityId = (appState.nameText + '-' + appState.urlText + '-' + appState.queryText)\r\n                .replaceAll('\"', '-')\r\n                .replaceAll('\\'', '-')\r\n                .replaceAll('/', '-')\r\n                .replaceAll('\\\\', '-')\r\n                .replaceAll('#', '-')\r\n                .replaceAll('?', '-');\r\n\r\n            const params: ITrackerParams = {\r\n                name: appState.nameText,\r\n                url: appState.urlText,\r\n                query: appState.queryText\r\n            }\r\n\r\n            // Creating a new entity by calling its 'init' method \r\n            appState.inProgress = true;\r\n            appState.entities.callEntity(entityId, 'init', params)\r\n                .catch(err => alert(err.message))\r\n                .finally(() => { appState.inProgress = false; });\r\n\r\n            appState.nameText = '';\r\n            appState.urlText = '';\r\n            appState.queryText = '';\r\n        }\r\n\r\n        private renderGraph(entityKey: string, entity: TrackerState, minTime: number): JSX.Element {\r\n\r\n            const firstValue = !!entity.points.length ? entity.points[0].value : undefined;\r\n\r\n            // If values look like numbers, rendering as a line graph\r\n            if (!isNaN(firstValue)) {\r\n                return this.renderLineGraph(entity, minTime);\r\n            }\r\n\r\n            // If it is an array of two numbers, then treating them as coordinates and rendering on a map\r\n            if (this.isConfigSettingDefined(AzureMapSubscriptionKey) && Array.isArray(firstValue) && (firstValue.length === 2) && (!isNaN(firstValue[0])) && (!isNaN(firstValue[1]))) {\r\n                return this.renderMap(entityKey, entity);\r\n            }\r\n\r\n            // Rendering as horizontal bars\r\n            return this.renderHorizontalBars(entity, minTime);\r\n        }\r\n\r\n        private renderLineGraph(entity: TrackerState, minTime: number): JSX.Element {\r\n\r\n            const data = entity.points.map(p => { return { x: new Date(p.time).getTime(), y: Number(p.value) } });\r\n            const now = new Date().getTime();\r\n\r\n            // Adding last point to the end, to make the graph look continuous\r\n            if (entity.points.length > 0) {\r\n                data.push({ x: now, y: Number(entity.points[entity.points.length - 1].value) });\r\n            }\r\n\r\n            return (<XYPlot width={window.innerWidth - 350} height={200} stackBy=\"y\" xType=\"time\" xDomain={[minTime, now]} margin={{ left: 80 }}>\r\n\r\n                <XAxis tickTotal={7} />\r\n                <YAxis />\r\n                <LineSeries data={data} color={this.stringToColorCode(entity.name)} />\r\n\r\n            </XYPlot>);\r\n        }\r\n\r\n        private renderHorizontalBars(entity: TrackerState, minTime: number): JSX.Element {\r\n\r\n            const firstTime = !!entity.points.length ? new Date(entity.points[0].time).getTime() : minTime;\r\n            const now = new Date().getTime();\r\n\r\n            const points = entity.points.map((p, i) => {\r\n                const curTime = new Date(p.time).getTime();\r\n                const nextTime = (i < (entity.points.length - 1)) ? new Date(entity.points[i + 1].time).getTime() : now;\r\n\r\n                return { stringValue: this.valueToString(p.value), timeDiff: nextTime - curTime };\r\n            });\r\n\r\n            return (<>\r\n                <XYPlot width={window.innerWidth - 350} height={100} stackBy=\"x\" xType=\"time\" xDomain={[minTime, now]} margin={{ left: 80, top: 30 }}>\r\n\r\n                    <XAxis tickTotal={7} />\r\n\r\n                    <HorizontalBarSeries opacity={0} barWidth={1} data={[{ y: 0, x: firstTime }]} />\r\n\r\n                    {points.map(p => {\r\n                        return (<HorizontalBarSeries key={p.stringValue} color={this.stringToColorCode(p.stringValue)}\r\n                            barWidth={1} data={[{ y: 0, x: p.timeDiff }]}\r\n                        />);\r\n                    })}\r\n\r\n                </XYPlot>\r\n\r\n                <DiscreteColorLegend className=\"histogram-legend\"\r\n                    items={points.map(p => {\r\n                        return {\r\n                            title: p.stringValue.substr(0, 100),\r\n                            color: this.stringToColorCode(p.stringValue)\r\n                        };\r\n                    })}\r\n                    orientation=\"horizontal\"\r\n                />\r\n\r\n            </>);\r\n        }\r\n\r\n        private renderMap(entityKey: string, entity: TrackerState): JSX.Element {\r\n\r\n            const points = entity.points.map(p => p.value);\r\n\r\n            if (!appState.mapDataSources[entityKey]) {\r\n                appState.mapDataSources[entityKey] = new atlas.source.DataSource();\r\n            }\r\n\r\n            appState.mapDataSources[entityKey].clear();\r\n            appState.mapDataSources[entityKey].add(new atlas.data.Feature(new atlas.data.LineString(points)));\r\n\r\n            const bounds = atlas.data.BoundingBox.fromPositions(points);\r\n\r\n            return (<MapControl entityKey={entityKey} dataSource={appState.mapDataSources[entityKey]} bounds={bounds} azureMapSubscriptionKey={AzureMapSubscriptionKey} />);\r\n        }\r\n\r\n        private valueToString(val: any): string {\r\n\r\n            if (typeof val === 'string') {\r\n                return val;\r\n            }\r\n\r\n            if (!val) {\r\n                return 'null';\r\n            }\r\n\r\n            return JSON.stringify(val);\r\n        }\r\n\r\n        private stringToColorCode(str: string): string {\r\n\r\n            // Taking hash out of input string (reversed, to make names like 'func1', 'func2' etc. look different)\r\n            var hashCode = 0;\r\n            for (var i = str.length - 1; i >= 0; i--) {\r\n                hashCode = ((hashCode << 5) - hashCode) + str.charCodeAt(i);\r\n                // Convert to positive 32-bit integer\r\n                hashCode &= 0x7FFFFFFF;\r\n            }\r\n\r\n            // min 6 hex digits\r\n            hashCode |= 0x100000;\r\n\r\n            // Not too white\r\n            hashCode &= 0xFFFFEF;\r\n\r\n            return '#' + hashCode.toString(16);\r\n        }\r\n\r\n        private isConfigSettingDefined(value: string) {\r\n            return !!value && !(\r\n                value.startsWith('%') && value.endsWith('%') // if this parameter isn't specified in Config Settings, the proxy returns env variable name instead\r\n            );\r\n        }\r\n    }\r\n);","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n\r\nimport './index.css';\r\nimport '../node_modules/react-vis/dist/style.css';\r\nimport '../node_modules/azure-maps-control/dist/atlas.css';\r\n\r\nimport { App } from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}